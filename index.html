<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ether Relay</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap');

    :root {
      --bg: #f6efe3;
      --panel: rgba(255, 255, 255, 0.92);
      --panel-strong: #0a1322;
      --accent: #27c2b1;
      --accent-2: #f29b3c;
      --accent-3: #ffd86f;
      --text: #261d14;
      --muted: #5d4f3f;
      --danger: #d94b5a;
      --shadow: 0 20px 50px rgba(7, 11, 21, 0.18);
      --glow: rgba(39, 194, 177, 0.35);
      --glow-warm: rgba(242, 155, 60, 0.35);
      --panel-stroke: rgba(242, 155, 60, 0.22);
      --glass: rgba(255, 255, 255, 0.7);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Segoe UI", sans-serif;
      color: var(--text);
      background:
        radial-gradient(900px 520px at 12% 10%, rgba(255, 214, 150, 0.62), transparent 60%),
        radial-gradient(780px 520px at 85% 12%, rgba(39, 194, 177, 0.28), transparent 55%),
        radial-gradient(720px 640px at 70% 85%, rgba(255, 187, 122, 0.24), transparent 60%),
        linear-gradient(145deg, #f8f1e5 0%, #f3e2c9 45%, #f5e8d8 100%);
      min-height: 100vh;
      position: relative;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.62), transparent 55%),
                        radial-gradient(circle at 80% 18%, rgba(255, 255, 255, 0.5), transparent 58%),
                        linear-gradient(120deg, rgba(255, 255, 255, 0.22), rgba(255, 255, 255, 0) 65%),
                        repeating-linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.1) 2px, transparent 2px, transparent 42px);
      opacity: 0.38;
      mix-blend-mode: soft-light;
      pointer-events: none;
      z-index: 0;
    }

    body::after {
      content: "";
      position: fixed;
      inset: -12%;
      background-image: radial-gradient(420px 380px at 12% 68%, rgba(39, 194, 177, 0.22), transparent 70%),
                        radial-gradient(520px 420px at 88% 78%, rgba(242, 155, 60, 0.2), transparent 70%);
      opacity: 0.65;
      pointer-events: none;
      z-index: 0;
    }

    body.high-contrast {
      --bg: #f3e9db;
      --panel: rgba(255, 255, 255, 0.98);
      --panel-strong: rgba(6, 9, 14, 0.98);
      --accent: #0f9486;
      --accent-2: #e07a23;
      --accent-3: #f7b728;
      --text: #1f1710;
      --muted: #4d3f32;
      --danger: #c1323f;
      --glow: rgba(15, 148, 134, 0.35);
      --glow-warm: rgba(224, 122, 35, 0.35);
      --panel-stroke: rgba(224, 122, 35, 0.3);
      --glass: rgba(255, 255, 255, 0.82);
    }

    body.high-contrast .panel { font-size: 16px; }
    body.high-contrast .pill { font-size: 14px; }
    body.high-contrast .badge { font-size: 15px; }
    body.high-contrast .badge strong { font-size: 16px; }

    body.reduce-motion .badge.combo,
    body.reduce-motion .live-overlay,
    body.reduce-motion .tutorial,
    body.reduce-motion .message,
    body.reduce-motion .wave-banner {
      transition: none;
    }

    body.reduce-motion .panel,
    body.reduce-motion .game-area,
    body.reduce-motion .panel::before,
    body.reduce-motion .controls li {
      animation: none;
    }

    @keyframes panel-rise {
      from { opacity: 0; transform: translateY(18px) scale(0.98); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }

    @keyframes panel-sheen {
      0%, 100% { transform: translateX(-35%) rotate(-8deg); opacity: 0.25; }
      50% { transform: translateX(45%) rotate(-8deg); opacity: 0.45; }
    }

    @keyframes list-in {
      from { opacity: 0; transform: translateY(8px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .layout {
      display: grid;
      grid-template-columns: 340px 1fr;
      gap: 24px;
      padding: 28px 28px 38px;
      max-width: 1400px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }

    .panel {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.96), rgba(255, 255, 255, 0.86));
      border: 1px solid var(--panel-stroke);
      border-radius: 18px;
      padding: 22px 22px 24px;
      box-shadow: var(--shadow), 0 0 0 1px rgba(255, 255, 255, 0.3) inset;
      backdrop-filter: blur(16px) saturate(1.05);
      position: relative;
      overflow: hidden;
      isolation: isolate;
      animation: panel-rise 0.8s ease both;
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: -40% -30% auto;
      height: 70%;
      background: linear-gradient(110deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.45), rgba(255, 255, 255, 0));
      opacity: 0.35;
      transform: translateX(-35%) rotate(-8deg);
      animation: panel-sheen 9s ease-in-out infinite;
      z-index: 0;
    }

    .panel::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 8% 8%, rgba(242, 155, 60, 0.16), transparent 36%),
                  radial-gradient(circle at 86% 20%, rgba(39, 194, 177, 0.2), transparent 42%);
      z-index: 0;
    }

    .panel > * { position: relative; z-index: 1; }

    .eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 12px;
      color: var(--accent);
      margin: 0 0 10px;
      font-weight: 700;
      display: inline-flex;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(39, 194, 177, 0.12);
      border: 1px solid rgba(39, 194, 177, 0.2);
    }

    h1 {
      margin: 0 0 12px;
      font-size: clamp(28px, 3vw, 36px);
      letter-spacing: -0.02em;
      font-family: "Chakra Petch", "Space Grotesk", sans-serif;
      color: #201812;
      text-shadow: 0 12px 26px rgba(24, 15, 8, 0.12);
    }

    p { color: var(--muted); line-height: 1.5; }

    .controls {
      list-style: none;
      padding: 0;
      margin: 18px 0 10px;
      display: grid;
      gap: 8px;
    }

    .controls li {
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(0, 0, 0, 0.06);
      border-left: 3px solid rgba(39, 194, 177, 0.35);
      border-radius: 12px;
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--text);
      box-shadow: 0 10px 18px rgba(12, 16, 24, 0.08);
      animation: list-in 0.6s ease both;
    }

    .controls li:nth-child(1) { animation-delay: 0.08s; }
    .controls li:nth-child(2) { animation-delay: 0.16s; }
    .controls li:nth-child(3) { animation-delay: 0.24s; }
    .controls li:nth-child(4) { animation-delay: 0.32s; }
    .controls li:nth-child(5) { animation-delay: 0.4s; }

    .kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 32px;
      height: 32px;
      padding: 0 10px;
      border-radius: 10px;
      border: 1px solid rgba(43, 179, 166, 0.25);
      background: linear-gradient(135deg, rgba(39, 194, 177, 0.2), rgba(39, 194, 177, 0.08));
      color: var(--accent);
      font-weight: 700;
      letter-spacing: 0.04em;
      font-size: 13px;
      box-shadow: inset 0 0 0 1px rgba(39, 194, 177, 0.25), 0 6px 14px rgba(39, 194, 177, 0.2);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 7px 12px;
      border-radius: 999px;
      background: linear-gradient(120deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));
      border: 1px solid rgba(242, 155, 60, 0.22);
      color: var(--text);
      font-size: 13px;
      margin-top: 12px;
      box-shadow: 0 8px 20px rgba(242, 155, 60, 0.12);
    }

    .pill strong { color: var(--accent); }

    .toggles {
      margin-top: 18px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 12px;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: rgba(255, 255, 255, 0.75);
      color: var(--text);
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      box-shadow: 0 10px 20px rgba(12, 16, 24, 0.08);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .toggle:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(12, 16, 24, 0.12);
    }

    .toggle input { accent-color: var(--accent); cursor: pointer; }

    .toggle-row {
      margin-top: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 14px;
      color: var(--muted);
    }

    .toggle-row input[type="range"] {
      width: 160px;
      accent-color: var(--accent);
    }

    .range-value {
      font-weight: 600;
      color: var(--accent);
      font-size: 13px;
    }

    .toggle-row.is-disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    .ghost-btn {
      margin-top: 12px;
      background: transparent;
      border: 1px solid rgba(39, 194, 177, 0.3);
      color: var(--text);
      box-shadow: none;
    }

    .ghost-btn:hover { box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25); }

    .game-area {
      position: relative;
      background: linear-gradient(160deg, rgba(11, 18, 32, 0.98), rgba(8, 12, 22, 0.98));
      border-radius: 20px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 26px 60px rgba(7, 9, 16, 0.35), 0 0 0 1px rgba(255, 255, 255, 0.06), 0 0 40px rgba(39, 194, 177, 0.15);
      min-height: 480px;
      display: grid;
      place-items: center;
      isolation: isolate;
      color: #f7f1e8;
      animation: panel-rise 0.8s ease both;
      animation-delay: 0.12s;
    }

    .game-area .badge,
    .game-area .effects-badge,
    .game-area .overlay-btn,
    .game-area .live-overlay,
    .game-area .tutorial,
    .game-area .wave-banner {
      color: #f7f1e8;
    }

    .game-area .badge span,
    .game-area .badge-note,
    .game-area .effects-badge {
      color: rgba(255, 255, 255, 0.7);
    }

    canvas {
      width: 100%;
      height: 100%;
      max-height: 760px;
      display: block;
      touch-action: none;
      background: radial-gradient(circle at 45% 28%, rgba(39, 194, 177, 0.16), transparent 40%),
                  radial-gradient(circle at 18% 78%, rgba(242, 155, 60, 0.14), transparent 35%),
                  #0a111f;
      border-radius: 14px;
      box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.35);
    }

    .hud {
      position: absolute;
      inset: 14px 14px auto 14px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      z-index: 2;
      pointer-events: none;
    }

    .badge {
      padding: 9px 14px;
      border-radius: 12px;
      background: rgba(8, 12, 20, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.14);
      backdrop-filter: blur(6px);
      color: var(--text);
      font-weight: 600;
      letter-spacing: 0.01em;
      font-family: "Chakra Petch", "Space Grotesk", sans-serif;
      box-shadow: inset 0 0 14px rgba(255, 255, 255, 0.04);
    }

    .badge span { color: var(--muted); font-weight: 500; margin-right: 8px; }

    .badge.danger { color: var(--danger); }
    .badge.danger-low { border-color: rgba(134, 242, 110, 0.35); color: #86f26e; }
    .badge.danger-med { border-color: rgba(255, 149, 90, 0.45); color: #ff955a; }
    .badge.danger-high { border-color: rgba(255, 94, 123, 0.65); color: #ff5e7b; box-shadow: 0 0 18px rgba(255, 94, 123, 0.25); }
    .badge.combo { transition: transform 0.2s ease, box-shadow 0.2s ease; }
    .badge.wave strong { color: var(--accent-2); }
    .badge.wave.wave-active { border-color: rgba(255, 149, 90, 0.45); box-shadow: 0 0 16px rgba(255, 149, 90, 0.2); }
    .badge.objective { border-color: rgba(39, 194, 177, 0.45); box-shadow: 0 0 18px rgba(39, 194, 177, 0.12); }
    .badge.objective strong { color: #7af6ff; }
    .badge.objective.is-urgent { border-color: rgba(255, 94, 123, 0.7); box-shadow: 0 0 20px rgba(255, 94, 123, 0.25); }
    .badge.objective.is-urgent strong { color: #ff8aa0; }
    .badge.objective.is-pulse { border-color: rgba(255, 209, 102, 0.6); box-shadow: 0 0 18px rgba(255, 209, 102, 0.25); }
    .badge.objective.is-pulse strong { color: #ffd166; }

    .effects-badge {
      position: absolute;
      left: 14px;
      bottom: 14px;
      padding: 8px 12px;
      background: rgba(10, 14, 22, 0.42);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      color: var(--muted);
      font-size: 13px;
      pointer-events: none;
      backdrop-filter: blur(6px);
    }

    .overlay-btn {
      position: absolute;
      top: 14px;
      right: 14px;
      z-index: 4;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(10, 14, 22, 0.45);
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      pointer-events: auto;
    }

    .live-overlay {
      position: absolute;
      top: 54px;
      right: 14px;
      width: min(280px, 82vw);
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 14px;
      padding: 12px 12px 10px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      z-index: 4;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .live-overlay.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateX(10px);
    }

    .live-overlay-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-weight: 700;
      color: var(--text);
    }

    .overlay-close {
      background: transparent;
      border: none;
      color: var(--muted);
      cursor: pointer;
      font-size: 13px;
    }

    .tutorial {
      position: absolute;
      top: 54px;
      left: 14px;
      width: min(360px, 86vw);
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 16px;
      padding: 14px 16px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      z-index: 4;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .tutorial.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateY(-8px);
    }

    .tutorial-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      font-weight: 700;
    }

    .tutorial ul {
      margin: 6px 0 0;
      padding-left: 18px;
      color: var(--muted);
      line-height: 1.4;
      font-size: 14px;
    }

    .wave-banner {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translate(-50%, -14px);
      padding: 8px 16px;
      border-radius: 999px;
      border: 1px solid rgba(242, 143, 59, 0.4);
      background: rgba(10, 14, 22, 0.5);
      color: var(--text);
      font-weight: 700;
      letter-spacing: 0.02em;
      box-shadow: var(--shadow);
      z-index: 4;
      opacity: 1;
      transition: opacity 0.25s ease, transform 0.25s ease;
      pointer-events: none;
    }

    .wave-banner.hidden {
      opacity: 0;
      transform: translate(-50%, -24px);
    }

    .message {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      backdrop-filter: blur(6px);
      background: linear-gradient(140deg, rgba(5, 9, 20, 0.72), rgba(5, 9, 20, 0.55));
      z-index: 3;
      transition: opacity 0.25s ease, visibility 0.25s ease;
    }

    .message.hidden { opacity: 0; visibility: hidden; }

    .card {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 16px;
      padding: 24px 22px;
      max-width: 420px;
      text-align: center;
      box-shadow: var(--shadow);
    }

    .card h2 { margin: 0 0 12px; letter-spacing: -0.01em; }
    .card p { margin: 0 0 16px; }

    .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 8px; text-align: left; margin: 12px 0 0; }
    .stat-row { background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 10px; padding: 10px 12px; color: var(--text); }
    .stat-row span { color: var(--muted); }

    .highscores { margin: 14px 0 0; text-align: left; background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 12px; padding: 12px; }
    .hs-title { font-weight: 700; color: var(--accent); margin-bottom: 8px; letter-spacing: 0.01em; }
    .hs-row { display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: center; padding: 6px 0; border-top: 1px solid rgba(255, 255, 255, 0.05); }
    .hs-row:first-of-type { border-top: none; }
    .hs-rank { display: inline-block; width: 28px; color: var(--muted); font-weight: 700; }
    .hs-name { font-weight: 700; color: var(--text); }
    .hs-score { font-variant-numeric: tabular-nums; font-weight: 800; color: #ffffff; }
    .hs-time { color: var(--muted); font-variant-numeric: tabular-nums; font-size: 13px; }
    .hs-empty { color: var(--muted); margin: 6px 0 2px; }
    .badge-stack { display: flex; flex-direction: column; line-height: 1.1; }
    .badge-note { font-size: 12px; color: var(--muted); margin-top: 2px; }
    .live-title { font-weight: 700; color: var(--accent-2); margin-bottom: 8px; letter-spacing: 0.01em; display: flex; align-items: center; gap: 8px; }
    .live-row { display: grid; grid-template-columns: auto 1fr auto auto; gap: 8px; align-items: center; padding: 6px 0; border-top: 1px solid rgba(255, 255, 255, 0.05); }
    .live-row:first-of-type { border-top: none; }
    .live-self { color: var(--accent-3); font-weight: 800; }
    .live-name { font-weight: 700; color: var(--text); }
    .live-score { font-variant-numeric: tabular-nums; font-weight: 800; color: #ffffff; }
    .live-time { color: var(--muted); font-variant-numeric: tabular-nums; font-size: 13px; }

    input[type=\"text\"] {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      background: rgba(255, 255, 255, 0.82);
      color: var(--text);
      font-size: 15px;
      margin: 0 0 12px;
      outline: none;
    }
    input[type=\"text\"]:focus {
      border-color: rgba(43, 179, 166, 0.45);
      box-shadow: 0 0 0 3px rgba(43, 179, 166, 0.15);
    }

    button {
      border: none;
      background: linear-gradient(120deg, var(--accent), #6fe3d6);
      color: #0b1513;
      font-weight: 800;
      letter-spacing: 0.04em;
      padding: 12px 18px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 14px 34px rgba(39, 194, 177, 0.3);
      transition: transform 0.15s ease, box-shadow 0.2s ease;
    }

    button:hover { transform: translateY(-2px) scale(1.01); box-shadow: 0 12px 36px rgba(43, 179, 166, 0.35); }
    button:active { transform: translateY(0); }

    .mobile-controls {
      position: absolute;
      right: 14px;
      bottom: 14px;
      display: grid;
      gap: 8px;
      z-index: 4;
      pointer-events: auto;
    }

    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 44px);
      grid-template-rows: repeat(3, 44px);
      gap: 6px;
      justify-content: center;
    }

    .dpad button, .pulse-btn {
      background: rgba(255, 255, 255, 0.12);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 10px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.28);
      touch-action: none;
    }

    .dpad button:active, .pulse-btn:active { background: rgba(43, 179, 166, 0.18); }

    .relay-list {
      margin: 16px 0 10px;
      display: grid;
      gap: 10px;
    }

    .relay-card {
      border-radius: 14px;
      padding: 12px 12px 10px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: linear-gradient(130deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.72));
      display: grid;
      gap: 6px;
      box-shadow: 0 12px 22px rgba(12, 16, 24, 0.08);
    }

    .relay-card.offline { opacity: 0.6; }

    .relay-title {
      display: flex;
      justify-content: space-between;
      font-weight: 700;
      color: #241a12;
    }

    .relay-meter {
      height: 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.08);
      overflow: hidden;
    }

    .relay-meter span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      width: 0%;
      transition: width 0.25s ease;
    }

    .relay-note {
      font-size: 12px;
      color: var(--muted);
    }

    .meter-badge {
      gap: 10px;
      align-items: center;
    }

    .meter {
      position: relative;
      width: 88px;
      height: 7px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.12);
      overflow: hidden;
    }

    .meter-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #86f26e, #ffd166);
      transition: width 0.2s ease;
    }

    .pulse-btn, .boost-btn { padding: 12px 14px; border-radius: 12px; }
    .boost-btn { background: rgba(140, 182, 255, 0.16); }
    .boost-btn:active { background: rgba(140, 182, 255, 0.3); }

    @media (max-width: 1024px) {
      .layout { grid-template-columns: 1fr; }
      .panel { order: 2; }
      .game-area { order: 1; min-height: 420px; }
    }

    @media (max-width: 720px) {
      .layout { padding: 18px 16px 24px; }
      .hud { inset: 10px; gap: 8px; }
      .badge { padding: 8px 10px; font-size: 13px; }
      .effects-badge { left: 10px; bottom: 10px; font-size: 12px; }
      .mobile-controls { display: grid; }
    }

    @media (min-width: 721px) {
      .mobile-controls { display: none; }
    }
  </style>
</head>
<body>
  <main class="layout">
    <section class="panel">
      <div class="eyebrow">Operation solaire</div>
      <h1>Ether Relay</h1>
      <p>Tu pilotes un drone qui doit reactiver des relais dans une tempete de debris. Collecte des noyaux, charge les relais et garde ton flux d energie eleve.</p>
      <div class="relay-list" id="relayList"></div>
      <ul class="controls">
        <li><span class="kbd">ZQSD</span><span class="kbd">Fleches</span> Deplacement precis</li>
        <li><span class="kbd">Espace</span> Onde de choc anti-debris</li>
        <li><span class="kbd">Shift</span><span class="kbd">B</span> Boost de propulsion</li>
        <li><span class="kbd">P</span> Pause / Reprise</li>
        <li><span class="kbd">T</span> Afficher le briefing</li>
      </ul>
      <div class="pill">
        <strong>Objectif</strong> Livrer les noyaux, charger les relais a 100% et maintenir un flux eleve. Utilise le boost pour traverser les pics de danger et profite des anomalies de flux pour engranger des points.
      </div>
      <div class="toggles">
        <label class="toggle"><input type="checkbox" id="contrastToggle"> Contraste fort</label>
        <label class="toggle"><input type="checkbox" id="motionToggle"> Motion douce</label>
        <label class="toggle"><input type="checkbox" id="shakeToggle"> Vibration ecran</label>
        <div class="toggle-row" id="shakeRow">
          Intensite
          <input type="range" id="shakeRange" min="0" max="100" value="60" aria-label="Intensite des vibrations">
          <span class="range-value" id="shakeValue">60%</span>
        </div>
      </div>
      <button class="ghost-btn" id="tutorialBtn">Briefing express</button>
    </section>

    <section class="game-area">
      <div class="hud">
        <div class="badge"><span>Score</span><strong id="score">0</strong></div>
        <div class="badge combo" id="flowBadge"><span>Flux</span><strong id="flow">x1.0</strong></div>
        <div class="badge meter-badge" id="integrityBadge"><span>Integrite</span><div class="meter"><div class="meter-fill" id="integrityFill"></div></div><strong id="integrityLabel">100%</strong></div>
        <div class="badge"><span>Cargo</span><strong id="cargo">0/5</strong></div>
        <div class="badge objective" id="objectiveBadge"><span>Priorite</span><div class="badge-stack"><strong id="objectiveLabel">Collecte</strong><div id="objectiveNote" class="badge-note"></div></div></div>
        <div class="badge danger" id="dangerBadge"><span>Menace</span><strong id="danger">Calme</strong></div>
        <div class="badge wave" id="waveBadge"><span>Front</span><strong id="waveLabel">Accalmie</strong></div>
        <div class="badge"><span>Temps</span><strong id="time">00:00</strong></div>
        <div class="badge"><span>Relais cible</span><div class="badge-stack"><strong id="relayFocus">Aucun</strong><div id="relayHint" class="badge-note"></div></div></div>
        <div class="badge"><span>Meilleur</span><div class="badge-stack"><strong id="best">0</strong><div id="bestPlayer" class="badge-note"></div></div></div>
        <div class="badge"><span>Reseau</span><div class="badge-stack"><strong id="peerTop">Solo</strong><div id="peerTopScore" class="badge-note"></div><div id="netStatus" class="badge-note"></div></div></div>
        <div class="badge"><span>Onde</span><strong id="pulse">Pret</strong></div>
        <div class="badge boost" id="boostBadge"><span>Boost</span><strong id="boost">Pret</strong></div>
      </div>
      <div class="effects-badge" id="effects">Modules: aucun</div>
      <button class="overlay-btn" id="liveToggle" type="button">Classement</button>
      <div class="live-overlay hidden" id="liveOverlay" aria-hidden="true">
        <div class="live-overlay-header">
          <span>Classement reseau</span>
          <button class="overlay-close" id="liveClose" type="button">Fermer</button>
        </div>
        <div id="liveOverlayBody"></div>
      </div>
      <div class="tutorial hidden" id="tutorial" aria-hidden="true">
        <div class="tutorial-header">
          <span>Briefing express</span>
          <button class="overlay-close" id="tutorialClose" type="button">Fermer</button>
        </div>
        <ul>
          <li>Deplace-toi avec ZQSD, fleches ou les touches tactiles.</li>
          <li>Ramasse les noyaux pour remplir ton cargo.</li>
          <li>Livraison: approche un relais pour le charger.</li>
          <li>Chaque livraison recharge l onde, et un relais sature restaure l integrite.</li>
          <li>Declenche l onde (Espace) pour repousser les debris.</li>
          <li>Active le boost (Shift ou B) pour traverser la zone dangereuse.</li>
          <li>Les anomalies de flux offrent un bonus si tu restes dedans.</li>
          <li>Les modules modifient la tempete: stase, phase, aimant, turbo.</li>
        </ul>
      </div>
      <div class="wave-banner hidden" id="waveBanner" aria-live="polite"></div>
      <canvas id="game" aria-label="Jeu Ether Relay" role="img"></canvas>
      <div id="message" class="message">
        <div class="card">
          <h2 id="status"></h2>
          <p id="summary">Choisis ton nom, collecte les noyaux, charge les relais et maintiens ton flux d energie sous pression.</p>
          <input type="text" id="playerName" maxlength="18" placeholder="Entre ton nom d operateur" aria-label="Nom de l operateur">
          <div class="stats" id="stats"></div>
          <div class="highscores" id="highscores"></div>
          <button id="start">Lancer la mission</button>
        </div>
      </div>
      <div class="mobile-controls" aria-hidden="true">
        <div class="dpad">
          <div></div><button data-dir="up">▲</button><div></div>
          <button data-dir="left">◀</button><div></div><button data-dir="right">▶</button>
          <div></div><button data-dir="down">▼</button><div></div>
        </div>
        <button class="pulse-btn" id="pulseBtn">Onde</button>
        <button class="boost-btn" id="boostBtn">Boost</button>
      </div>
    </section>
  </main>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const dangerEl = document.getElementById('danger');
    const dangerBadge = document.getElementById('dangerBadge');
    const flowEl = document.getElementById('flow');
    const flowBadge = document.getElementById('flowBadge');
    const timeEl = document.getElementById('time');
    const bestEl = document.getElementById('best');
    const bestPlayerEl = document.getElementById('bestPlayer');
    const peerTopEl = document.getElementById('peerTop');
    const peerTopScoreEl = document.getElementById('peerTopScore');
    const netStatusEl = document.getElementById('netStatus');
    const pulseEl = document.getElementById('pulse');
    const effectsEl = document.getElementById('effects');
    const message = document.getElementById('message');
    const startBtn = document.getElementById('start');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');
    const statsEl = document.getElementById('stats');
    const highscoresEl = document.getElementById('highscores');
    const relayListEl = document.getElementById('relayList');
    const liveboardEl = document.getElementById('liveboard');
    const nameInput = document.getElementById('playerName');
    const tutorialBtn = document.getElementById('tutorialBtn');
    const tutorialEl = document.getElementById('tutorial');
    const tutorialClose = document.getElementById('tutorialClose');
    const liveToggle = document.getElementById('liveToggle');
    const liveOverlay = document.getElementById('liveOverlay');
    const liveOverlayBody = document.getElementById('liveOverlayBody');
    const liveClose = document.getElementById('liveClose');
    const pulseBtn = document.getElementById('pulseBtn');
    const boostBtn = document.getElementById('boostBtn');
    const contrastToggle = document.getElementById('contrastToggle');
    const motionToggle = document.getElementById('motionToggle');
    const shakeToggle = document.getElementById('shakeToggle');
    const shakeRange = document.getElementById('shakeRange');
    const shakeValue = document.getElementById('shakeValue');
    const shakeRow = document.getElementById('shakeRow');
    const waveLabelEl = document.getElementById('waveLabel');
    const waveBadge = document.getElementById('waveBadge');
    const waveBanner = document.getElementById('waveBanner');
    const integrityFill = document.getElementById('integrityFill');
    const integrityLabel = document.getElementById('integrityLabel');
    const cargoEl = document.getElementById('cargo');
    const objectiveBadge = document.getElementById('objectiveBadge');
    const objectiveLabelEl = document.getElementById('objectiveLabel');
    const objectiveNoteEl = document.getElementById('objectiveNote');
    const boostEl = document.getElementById('boost');
    const boostBadge = document.getElementById('boostBadge');
    const relayFocusEl = document.getElementById('relayFocus');
    const relayHintEl = document.getElementById('relayHint');

    function randomColor() {
      const h = Math.floor(Math.random() * 360);
      return `hsl(${h}, 80%, 65%)`;
    }

    function randomId(prefix = 'id') {
      try {
        const bytes = new Uint8Array(10);
        (window.crypto && crypto.getRandomValues ? crypto.getRandomValues(bytes) : bytes.fill(0).map((_, i) => bytes[i] = Math.floor(Math.random() * 256)));
        const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        return `${prefix}-${hex}`;
      } catch (e) {
        return `${prefix}-${Math.random().toString(36).slice(2)}${Math.random().toString(36).slice(2)}`;
      }
    }

    const urlParams = new URLSearchParams(location.search);
    const customApi = (urlParams.get('api') || '').trim();
    const basePath = location.pathname.startsWith('/ether-relay')
      ? '/ether-relay'
      : (location.pathname.startsWith('/space-cleaner') ? '/space-cleaner' : '');
    const originApi = !location.origin.startsWith('file') ? `${location.origin}${basePath}` : '';
    const defaultApi = `http://localhost:8000${basePath}`;
    const baseApi = customApi || originApi || defaultApi;
    const API_URL = `${baseApi.replace(/\/$/, '')}/api/state`;

    const CONFIG = {
      syncIntervalMs: 250,
      boardIntervalMs: 2000,
      uiIntervalMs: 260,
      maxPeers: 5,
      maxHazards: 18,
      pulse: { duration: 0.3, cooldown: 2.6, reach: 240, force: 640, destroyRatio: 0.45 },
      boost: { duration: 0.65, cooldown: 4.2, multiplier: 1.6 },
      powerups: { slow: 4, shield: 8, magnet: 6, overdrive: 6, repair: 0 },
      magnetReach: 240,
      hazardTTL: { min: 13, jitter: 8 },
      trail: { max: 22, baseLife: 0.2, speedLife: 0.2 },
      shake: { max: 15, decay: 3.1 },
      net: { pos: 6, score: 25, time: 1, heartbeat: 1500 },
      speedSmooth: 0.2,
      speedMargin: 10,
      spawn: {
        hazardDecay: 0.03,
        hazardBase: 1.6,
        hazardMin: 0.65,
        hazardJitter: 0.45,
        hazardFallback: 0.7,
        orbBase: 2.1,
        orbJitter: 0.9,
        powerupBase: 9,
        powerupJitter: 5.5,
      },
      assist: { hitSlow: 1.4, relayRepair: 12 },
      waves: {
        active: 16,
        rest: 7,
        announce: 2.2,
        profiles: [
          { name: 'Front ionique', hazardSpeed: 1.2, hazardSize: 0.95, spawnRate: 0.8, reward: 'slow' },
          { name: 'Eclats lourds', hazardSpeed: 0.85, hazardSize: 1.35, spawnRate: 1.05, reward: 'overdrive' },
          { name: 'Courants erratiques', hazardSpeed: 1.1, hazardSize: 1.05, spawnRate: 0.9, reward: 'magnet' },
          { name: 'Voile plasma', hazardSpeed: 1.25, hazardSize: 0.9, spawnRate: 1.15, reward: 'shield' },
          { name: 'Cisaillement solaire', hazardSpeed: 1.05, hazardSize: 1.2, spawnRate: 1.25, reward: 'repair' },
        ],
      },
      relay: { count: 3, maxCharge: 100, unitCharge: 20, cooldown: 2.6, surgeRadius: 240 },
      cargo: { max: 5 },
      flow: { max: 4.6, decayDelay: 4.5, decayRate: 0.16, bump: 0.14, surgeBonus: 0.4 },
      integrity: { max: 100, hit: 22 },
      anomaly: { cooldown: 26, duration: 12, radius: 170, rewardRate: 28, pulseRecharge: 0.45 },
    };

    const POWERUP_LABELS = {
      slow: 'Stase',
      shield: 'Phase',
      magnet: 'Aimant',
      repair: 'Reparation',
      overdrive: 'Turbo',
    };

    const PREF_KEYS = {
      tutorialSeen: 'ether-relay-tutorial-seen',
      highContrast: 'ether-relay-contrast',
      reducedMotion: 'ether-relay-reduced-motion',
      shake: 'ether-relay-shake',
      shakeIntensity: 'ether-relay-shake-intensity',
    };

    function readBool(key, fallback = false) {
      try {
        const value = localStorage.getItem(key);
        if (value === null) return fallback;
        return value === '1' || value === 'true';
      } catch (e) {
        return fallback;
      }
    }

    function readNumber(key, fallback = 0) {
      try {
        const value = localStorage.getItem(key);
        if (value === null) return fallback;
        const parsed = Number(value);
        return Number.isFinite(parsed) ? parsed : fallback;
      } catch (e) {
        return fallback;
      }
    }

    function writePref(key, value) {
      try {
        localStorage.setItem(key, String(value));
      } catch (e) {}
    }

    const prefs = {
      highContrast: false,
      reducedMotion: false,
      shake: true,
      shakeIntensity: 0.6,
    };

    function applyPreferenceClasses() {
      document.body.classList.toggle('high-contrast', prefs.highContrast);
      document.body.classList.toggle('reduce-motion', prefs.reducedMotion);
    }

    function syncPreferenceControls() {
      if (contrastToggle) contrastToggle.checked = prefs.highContrast;
      if (motionToggle) motionToggle.checked = prefs.reducedMotion;
      if (shakeToggle) shakeToggle.checked = prefs.shake;
      if (shakeRange) shakeRange.value = String(Math.round(prefs.shakeIntensity * 100));
      if (shakeValue) shakeValue.textContent = `${Math.round(prefs.shakeIntensity * 100)}%`;
      if (shakeRow) shakeRow.classList.toggle('is-disabled', !prefs.shake);
      if (shakeRange) shakeRange.disabled = !prefs.shake;
    }

    let storedClientId = null;
    try {
      storedClientId = localStorage.getItem('ether-relay-client-id') || localStorage.getItem('ether-relay-id');
    } catch (e) {
      storedClientId = null;
    }
    let storedInstanceId = null;
    try {
      storedInstanceId = sessionStorage.getItem('ether-relay-instance-id');
      if (!storedInstanceId) {
        storedInstanceId = randomId('t');
        sessionStorage.setItem('ether-relay-instance-id', storedInstanceId);
      }
    } catch (e) {
      storedInstanceId = randomId('t');
    }
    const network = {
      clientId: storedClientId || randomId('c'),
      instanceId: storedInstanceId,
      sessionId: randomId('s'),
      color: randomColor(),
      name: 'Operateur-' + Math.random().toString(36).slice(2, 5),
      peers: new Map(),
      lastSync: 0,
      enabled: true,
      lastSent: { x: 0, y: 0, score: 0, time: 0 },
      board: [],
      lastBoardFetch: 0,
      lastServerTime: 0,
      lastSendAt: 0,
      lastSuccessAt: 0,
      lastServerPerf: 0,
      latencyMs: 0,
      connected: false,
      pulseSeq: 0,
    };

    // stabilise l'identité multijoueur (évite de changer de clientId à chaque rechargement)
    try {
      localStorage.setItem('ether-relay-client-id', network.clientId);
    } catch (e) {}
    let leaveSent = false;

    function leaveServer() {
      if (!network.enabled || leaveSent) return;
      leaveSent = true;
      const url = API_URL.replace('/state', '/leave');
      const payload = JSON.stringify({
        sessionId: network.sessionId,
        clientId: network.clientId,
        instanceId: network.instanceId,
      });
      try {
        if (navigator.sendBeacon) {
          navigator.sendBeacon(url, new Blob([payload], { type: 'application/json' }));
          return;
        }
      } catch (e) {
        // ignore beacon errors
      }
      try {
        fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: payload,
          keepalive: true,
        });
      } catch (e) {
        // ignore fetch errors
      }
    }
    // évite de laisser des sessions "fantômes" côté serveur
    window.addEventListener('pagehide', leaveServer);
    window.addEventListener('beforeunload', leaveServer);
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') leaveServer();
    });
    const SYNC_INTERVAL = CONFIG.syncIntervalMs;
    const MAX_PEERS = CONFIG.maxPeers;

    const state = {
      running: false,
      paused: false,
      last: 0,
      player: { x: 0, y: 0, vx: 0, vy: 0, r: 14 },
      color: network.color,
      name: network.name,
      hazards: [],
      orbs: [],
      powerups: [],
      particles: [],
      stars: [],
      timers: { hazard: 0, orb: 0, powerup: 7, anomaly: 0 },
      score: 0,
      best: 0,
      bestTime: 0,
      sessionBest: 0,
      sessionBestTime: 0,
      integrity: CONFIG.integrity.max,
      maxIntegrity: CONFIG.integrity.max,
      cargo: 0,
      maxCargo: CONFIG.cargo.max,
      multiplier: 1,
      maxMultiplier: 1,
      lastDelivery: 0,
      time: 0,
      pulseCooldown: 0,
      pulseActive: 0,
      boostActive: 0,
      boostCooldown: 0,
      hitCooldown: 0,
      assistSlow: 0,
      playerSpeedAvg: 0,
      lastUiUpdate: 0,
      lastSave: 0,
      shieldCharges: 0,
      effects: { slow: 0, shield: 0, magnet: 0, overdrive: 0 },
      shake: { power: 0 },
      wave: { index: -1, active: false, profile: null, timeLeft: 0, show: 0 },
      anomaly: { active: false, x: 0, y: 0, r: 0, ttl: 0, glow: 0 },
      stats: { cores: 0, deliveries: 0, relays: 0, hits: 0 },
      comboFlash: 0,
      liveboardOpen: false,
      tutorialOpen: false,
      danger: { level: 'low', nearest: Infinity, density: 0 },
      thrust: 0,
      trail: [],
      relays: [],
      highscores: [],
      bestName: 'Operateur',
      serverBest: 0,
      serverBestTime: 0,
      serverBestName: '',
    };

    let tutorialSeen = false;

    const input = {
      up: false,
      down: false,
      left: false,
      right: false,
    };

    const touchInput = {
      up: false,
      down: false,
      left: false,
      right: false,
      active: false,
      pointerId: null,
    };

    const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
    const lerp = (a, b, t) => a + (b - a) * t;
    const escapeHtml = (str) => String(str || '').replace(/[&<>"']/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c] || c));

    function getMotionScale() {
      return prefs.reducedMotion ? 0.55 : 1;
    }

    function getTrailMax() {
      return Math.max(6, Math.round(CONFIG.trail.max * getMotionScale()));
    }

    function formatClock(seconds) {
      const s = Math.max(0, Number(seconds) || 0);
      const total = Math.floor(s);
      const ss = total % 60;
      const mmTotal = Math.floor(total / 60);
      const mm = mmTotal % 60;
      const hh = Math.floor(mmTotal / 60);
      if (hh > 0) return `${hh}:${String(mm).padStart(2, '0')}:${String(ss).padStart(2, '0')}`;
      return `${String(mm).padStart(2, '0')}:${String(ss).padStart(2, '0')}`;
    }
    const particlePool = [];
    const hazardPool = [];
    const bgCanvas = document.createElement('canvas');
    const bgCtx = bgCanvas.getContext('2d');

    function loadBests() {
      state.best = 0;
      state.bestTime = 0;
      state.highscores = [];
      state.bestName = 'Operateur';
      updateServerBest();
    }

    function saveBests() {
      // scores locaux desactives (leaderboard serveur uniquement)
    }

    function resizeCanvas() {
      const w = Math.min(window.innerWidth - 48, 1200);
      const h = Math.min(window.innerHeight - 180, 760);
      canvas.width = Math.max(640, w);
      canvas.height = Math.max(420, h);
      renderBackgroundBase();
      initStars();
      clampRelaysToCanvas();
    }

    function clampRelaysToCanvas() {
      if (!state.relays || !state.relays.length) return;
      const pad = 80;
      state.relays.forEach(relay => {
        relay.x = clamp(relay.x, pad, canvas.width - pad);
        relay.y = clamp(relay.y, pad, canvas.height - pad);
      });
    }

    function renderBackgroundBase() {
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
      const base = bgCtx.createLinearGradient(0, 0, bgCanvas.width, bgCanvas.height);
      base.addColorStop(0, '#0a111f');
      base.addColorStop(0.5, '#0c1a2b');
      base.addColorStop(1, '#0a0f1b');
      bgCtx.fillStyle = base;
      bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

      const glow = bgCtx.createRadialGradient(bgCanvas.width * 0.55, bgCanvas.height * 0.3, 80, bgCanvas.width * 0.55, bgCanvas.height * 0.3, Math.max(bgCanvas.width, bgCanvas.height));
      glow.addColorStop(0, 'rgba(39, 194, 177, 0.12)');
      glow.addColorStop(1, 'rgba(5, 9, 20, 0)');
      bgCtx.fillStyle = glow;
      bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

      bgCtx.save();
      bgCtx.globalCompositeOperation = 'screen';
      for (let i = 0; i < 6; i++) {
        const x = Math.random() * bgCanvas.width;
        const y = Math.random() * bgCanvas.height;
        const r = (Math.random() * 0.35 + 0.25) * Math.max(bgCanvas.width, bgCanvas.height);
        const tint = Math.random() < 0.6 ? 'rgba(39, 194, 177, 0.12)' : 'rgba(242, 155, 60, 0.12)';
        const nebula = bgCtx.createRadialGradient(x, y, 0, x, y, r);
        nebula.addColorStop(0, tint);
        nebula.addColorStop(1, 'rgba(0, 0, 0, 0)');
        bgCtx.fillStyle = nebula;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
      }
      bgCtx.restore();

      bgCtx.save();
      bgCtx.globalCompositeOperation = 'lighter';
      for (let i = 0; i < 240; i++) {
        const x = Math.random() * bgCanvas.width;
        const y = Math.random() * bgCanvas.height;
        const r = Math.random() * 1.2 + 0.2;
        const hue = Math.random() < 0.7 ? 190 + Math.random() * 30 : 30 + Math.random() * 20;
        const alpha = Math.random() * 0.5 + 0.2;
        bgCtx.fillStyle = `hsla(${hue}, 80%, 85%, ${alpha})`;
        bgCtx.beginPath();
        bgCtx.arc(x, y, r, 0, Math.PI * 2);
        bgCtx.fill();
      }
      bgCtx.restore();
    }

    function initStars() {
      const total = Math.min(110, Math.round(60 + (canvas.width * canvas.height) / 22000));
      state.stars = Array.from({ length: total }, () => {
        const depth = Math.random();
        const hue = Math.random() < 0.7 ? 190 + Math.random() * 30 : 30 + Math.random() * 25;
        return {
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          s: lerp(0.4, 2.6, depth),
          speed: lerp(8, 42, depth),
          depth,
          hue,
          tw: Math.random() * Math.PI * 2,
          drift: (Math.random() - 0.5) * 12,
        };
      });
    }

    function resetGame() {
      resizeCanvas();
      state.player = { x: canvas.width / 2, y: canvas.height * 0.65, vx: 0, vy: 0, r: 14 };
      state.color = network.color;
      state.name = network.name;
      clearTouchInput();
      hazardPool.push(...state.hazards);
      particlePool.push(...state.particles);
      state.hazards = [];
      state.orbs = [];
      state.powerups = [];
      state.particles = [];
      network.peers.clear();
      network.lastSent = { x: 0, y: 0, score: 0, time: 0 };
      network.board = [];
      network.lastBoardFetch = 0;
      state.score = 0;
      state.sessionBest = 0;
      state.sessionBestTime = 0;
      state.best = 0;
      state.bestTime = 0;
      state.bestName = state.name || 'Operateur';
      state.integrity = CONFIG.integrity.max;
      state.maxIntegrity = CONFIG.integrity.max;
      state.cargo = 0;
      state.maxCargo = CONFIG.cargo.max;
      state.multiplier = 1;
      state.maxMultiplier = 1;
      state.lastDelivery = 0;
      state.time = 0;
      state.danger = { level: 'low', nearest: Infinity, density: 0 };
      state.stats = { cores: 0, deliveries: 0, relays: 0, hits: 0 };
      state.pulseCooldown = 0;
      state.pulseActive = 0;
      state.boostActive = 0;
      state.boostCooldown = 0;
      state.hitCooldown = 0;
      state.assistSlow = 0;
      state.playerSpeedAvg = 0;
      state.lastUiUpdate = 0;
      state.lastSave = 0;
      state.shieldCharges = 0;
      state.effects = { slow: 0, shield: 0, magnet: 0, overdrive: 0 };
      state.shake.power = 0;
      state.wave = { index: -1, active: false, profile: null, timeLeft: 0, show: 0 };
      state.anomaly = { active: false, x: 0, y: 0, r: 0, ttl: 0, glow: 0 };
      state.thrust = 0;
      state.trail = [];
      state.relays = [];
      state.timers.hazard = Math.max(1, CONFIG.spawn.hazardMin + 0.8);
      state.timers.orb = CONFIG.spawn.orbBase * 0.35;
      state.timers.powerup = CONFIG.spawn.powerupBase - 1;
      state.timers.anomaly = CONFIG.anomaly.cooldown * 0.6;
      network.lastServerTime = 0;
      network.lastSendAt = 0;
      network.lastSuccessAt = 0;
      network.latencyMs = 0;
      network.connected = false;
      state.running = true;
      state.paused = false;
      state.comboFlash = 0;
      setLiveOverlay(false);
      setTutorialOpen(false, false);
      message.classList.add('hidden');
      maybeShowTutorial();
      statusEl.textContent = '';
      summaryEl.textContent = 'Collecte les noyaux, charge les relais, profite des anomalies et declenche l onde de choc quand la tempete se resserre.';
      statsEl.innerHTML = '';
      renderHighscores();
      startBtn.textContent = 'Relancer la mission';
      initRelays();
      try {
        localStorage.setItem('ether-relay-client-id', network.clientId);
        localStorage.setItem('ether-relay-id', network.clientId);
      } catch (e) {
        // stockage non disponible
      }
    }

    function formatTime(sec) {
      const m = Math.floor(sec / 60).toString().padStart(2, '0');
      const s = Math.floor(sec % 60).toString().padStart(2, '0');
      return `${m}:${s}`;
    }

    function trackServerTime(serverTime) {
      const t = Number(serverTime);
      if (!Number.isFinite(t) || t <= 0) return;
      network.lastServerTime = t;
      network.lastServerPerf = performance.now();
    }

    function getServerNow() {
      if (!network.lastServerTime || !network.lastServerPerf) return 0;
      const delta = Math.max(0, (performance.now() - network.lastServerPerf) / 1000);
      return network.lastServerTime + delta;
    }

    function setLiveOverlay(open) {
      state.liveboardOpen = open;
      if (!liveOverlay) return;
      liveOverlay.classList.toggle('hidden', !open);
      liveOverlay.setAttribute('aria-hidden', open ? 'false' : 'true');
    }

    function setTutorialOpen(open, persist = true) {
      state.tutorialOpen = open;
      if (!tutorialEl) return;
      tutorialEl.classList.toggle('hidden', !open);
      tutorialEl.setAttribute('aria-hidden', open ? 'false' : 'true');
      if (!open && persist) {
        tutorialSeen = true;
        writePref(PREF_KEYS.tutorialSeen, '1');
      }
    }

    function maybeShowTutorial() {
      if (!tutorialSeen) {
        setTutorialOpen(true, false);
      }
    }

    function applyPreferences() {
      tutorialSeen = readBool(PREF_KEYS.tutorialSeen, false);
      prefs.highContrast = readBool(PREF_KEYS.highContrast, false);
      prefs.reducedMotion = readBool(PREF_KEYS.reducedMotion, false);
      prefs.shake = readBool(PREF_KEYS.shake, true);
      prefs.shakeIntensity = Math.min(Math.max(readNumber(PREF_KEYS.shakeIntensity, 0.6), 0), 1);
      applyPreferenceClasses();
      syncPreferenceControls();
    }

    function renderHighscores() {
      const container = highscoresEl;
      if (!container) return;
      if (!network.board || !network.board.length) {
        container.innerHTML = '<div class="hs-title">Meilleurs scores</div><div class="hs-empty">Aucun score serveur</div>';
        return;
      }
      const source = network.board.slice(0, 5).map(h => ({
        name: h.name || 'Operateur',
        score: Math.floor(h.score || h.best || 0),
        time: Math.floor(h.time || h.bestTime || 0),
      }));
      const rows = source.map((h, i) => {
        const safeName = escapeHtml(h.name || 'Operateur');
        return `
          <div class="hs-row">
            <div><span class="hs-rank">#${i + 1}</span><span class="hs-name">${safeName}</span></div>
            <div class="hs-score">${Math.floor(h.score)}</div>
            <div class="hs-time">${formatTime(h.time || 0)}</div>
          </div>
        `;
      }).join('');
      container.innerHTML = `<div class="hs-title">Meilleurs scores</div>${rows}`;
    }

    function getSelfLeaderboardName() {
      return state.name || network.name || 'Operateur';
    }

    function computeDanger() {
      const density = state.hazards.length / CONFIG.maxHazards;
      if (!state.hazards.length) {
        return { level: 'low', nearest: Infinity, density };
      }
      const nearest = state.hazards.reduce((acc, h) => {
        const dist = Math.hypot((h.x || 0) - state.player.x, (h.y || 0) - state.player.y) - (h.r || 0);
        return Math.min(acc, dist);
      }, Infinity);
      let level = 'low';
      if (nearest < 140 || density > 0.75) level = 'high';
      else if (nearest < 240 || density > 0.5) level = 'med';
      return { level, nearest, density };
    }

    function getSpawnEase() {
      const density = state.hazards.length / CONFIG.maxHazards;
      const integrityRatio = state.maxIntegrity ? state.integrity / state.maxIntegrity : 1;
      const densityEase = clamp((density - 0.35) / 0.55, 0, 1);
      const integrityEase = clamp((0.7 - integrityRatio) / 0.7, 0, 1);
      return 1 + densityEase * 0.9 + integrityEase * 0.7;
    }

    function updateWave(dt) {
      const profiles = CONFIG.waves && CONFIG.waves.profiles ? CONFIG.waves.profiles : [];
      if (!profiles.length) {
        if (state.wave.show > 0) state.wave.show = Math.max(0, state.wave.show - dt);
        state.wave.active = false;
        state.wave.profile = null;
        state.wave.timeLeft = 0;
        return { speed: 1, size: 1, spawnRate: 1 };
      }
      const cycle = CONFIG.waves.active + CONFIG.waves.rest;
      const shiftedTime = state.time + CONFIG.waves.active;
      const idx = Math.floor(shiftedTime / cycle) % profiles.length;
      const t = shiftedTime % cycle;
      const active = t < CONFIG.waves.active;
      if (active) {
        const profile = profiles[idx];
        if (!state.wave.active || state.wave.index !== idx) {
          state.wave.index = idx;
          state.wave.active = true;
          state.wave.profile = profile;
          state.wave.show = CONFIG.waves.announce;
          if (profile.reward) spawnPowerup(profile.reward);
          triggerShake(0.28);
        }
        state.wave.timeLeft = Math.max(0, CONFIG.waves.active - t);
      } else {
        state.wave.active = false;
        state.wave.profile = null;
        state.wave.timeLeft = 0;
      }
      if (state.wave.show > 0) state.wave.show = Math.max(0, state.wave.show - dt);
      if (state.wave.active && state.wave.profile) {
        return {
          speed: state.wave.profile.hazardSpeed || 1,
          size: state.wave.profile.hazardSize || 1,
          spawnRate: state.wave.profile.spawnRate || 1,
        };
      }
      return { speed: 1, size: 1, spawnRate: 1 };
    }

    function setServerBoard(board) {
      if (!Array.isArray(board)) return;
      network.board = board
        .map(p => ({
          id: String(p.id || ''),
          name: p.name || 'Operateur',
          score: Math.floor(Number(p.score || p.best || 0) || 0),
          time: Math.floor(Number(p.time || p.bestTime || 0) || 0),
          color: p.color || '#7af6ff',
          created: Number(p.created || p.updated) || 0,
        }))
        .filter(p => p.score > 0)
        .sort((a, b) => b.score - a.score || b.time - a.time)
        .slice(0, 20);
      updateServerBest();
    }

    function updateServerBest() {
      const top = network.board && network.board.length ? network.board[0] : null;
      if (top) {
        state.serverBest = Number(top.score) || 0;
        state.serverBestTime = Number(top.time) || 0;
        state.serverBestName = top.name || '';
      } else {
        state.serverBest = 0;
        state.serverBestTime = 0;
        state.serverBestName = '';
      }
    }

    function maybeUpdateBoards(force = false) {
      const now = performance.now();
      if (!force && state.lastUiUpdate && now - state.lastUiUpdate < CONFIG.uiIntervalMs) return;
      state.lastUiUpdate = now;
      renderLiveboard();
      renderHighscores();
    }

    function renderLiveboard() {
      const targets = [];
      if (liveboardEl) targets.push({ el: liveboardEl, withTitle: true });
      if (liveOverlayBody) targets.push({ el: liveOverlayBody, withTitle: false });
      if (!targets.length) return;
      const selfName = getSelfLeaderboardName();
      const entries = [
        { id: network.sessionId, name: selfName, score: state.sessionBest || 0, time: state.sessionBestTime || 0, self: true },
        ...Array.from(network.peers.values()).map(p => ({
          id: p.id,
          name: p.name || 'Operateur',
          score: p.score || p.best || 0,
          time: p.time || p.bestTime || 0,
          self: false,
        })),
      ].filter(e => e.name);

      if (!entries.length) {
        targets.forEach(({ el, withTitle }) => {
          el.innerHTML = `${withTitle ? '<div class="live-title">Classement reseau</div>' : ''}<div class="hs-empty">Aucun joueur connecte</div>`;
        });
        return;
      }

      const rows = entries
        .sort((a, b) => (b.score || 0) - (a.score || 0) || (b.time || 0) - (a.time || 0))
        .slice(0, 8)
        .map((e, i) => {
          const cls = e.self ? 'live-self' : 'live-name';
          const safeName = escapeHtml(e.name);
          return `
            <div class="live-row">
              <div class="hs-rank">#${i + 1}</div>
              <div class="${cls}">${safeName}</div>
              <div class="live-score">${Math.floor(e.score || 0)}</div>
              <div class="live-time">${formatTime(e.time || 0)}</div>
            </div>
          `;
        }).join('');
      targets.forEach(({ el, withTitle }) => {
        el.innerHTML = `${withTitle ? '<div class="live-title">Classement reseau</div>' : ''}${rows}`;
      });
    }

    function prunePeers() {
      const now = Date.now();
      for (const [id, peer] of network.peers.entries()) {
        if (now - peer.lastSeen > CONFIG.net.heartbeat * 4) network.peers.delete(id);
      }
    }

    async function fetchBoard() {
      try {
        const start = performance.now();
        const res = await fetch(API_URL.replace('/state', '/board'), { method: 'GET' });
        if (!res.ok) return;
        const data = await res.json();
        if (!data || !Array.isArray(data.board)) return;
        network.latencyMs = performance.now() - start;
        network.connected = true;
        network.lastSuccessAt = performance.now();
        trackServerTime(data.serverTime);
        setServerBoard(data.board);
        maybeUpdateBoards(true);
      } catch (e) {
        // ignore fetch errors, retry later
      }
    }

    async function submitScore() {
      if (!network.enabled) return;
      const score = Math.floor(state.score);
      const t = Math.floor(state.time);
      if (score <= 0) return;
      try {
        const res = await fetch(API_URL.replace('/state', '/score'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            sessionId: network.sessionId,
            clientId: network.clientId,
            name: state.name || network.name,
            color: network.color,
            score,
            time: t,
          }),
        });
        if (!res.ok) return;
        const data = await res.json();
        if (!data || !Array.isArray(data.board)) return;
        trackServerTime(data.serverTime);
        setServerBoard(data.board);
        maybeUpdateBoards(true);
      } catch (e) {
        // ignore submit errors
      }
    }

    async function syncPlayers() {
      if (!network.enabled) return;
      const now = performance.now();
      const dx = Math.abs(state.player.x - network.lastSent.x);
      const dy = Math.abs(state.player.y - network.lastSent.y);
      const dScore = Math.abs(Math.floor(state.score) - (network.lastSent.score || 0));
      const dTime = Math.abs(Math.floor(state.time) - (network.lastSent.time || 0));
      const moved = dx > CONFIG.net.pos || dy > CONFIG.net.pos || dScore > CONFIG.net.score || dTime > CONFIG.net.time;
      if (!moved && now - network.lastSendAt < CONFIG.net.heartbeat) return;
      try {
        const start = performance.now();
        const res = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id: network.sessionId,
            sessionId: network.sessionId,
            clientId: network.clientId,
            instanceId: network.instanceId,
            color: network.color,
            name: network.name,
            x: state.player.x,
            y: state.player.y,
            score: Math.floor(state.score),
            time: Math.floor(state.time),
            best: Math.floor(state.sessionBest),
            bestTime: Math.floor(state.sessionBestTime),
            pulseSeq: network.pulseSeq,
            since: network.lastServerTime || 0,
          }),
        });
        network.lastSent = {
          x: state.player.x,
          y: state.player.y,
          score: Math.floor(state.score),
          time: Math.floor(state.time),
        };
        network.lastSendAt = now;
        if (!res.ok) throw new Error('sync failed');
        const data = await res.json();
        network.latencyMs = performance.now() - start;
        network.connected = true;
        network.lastSuccessAt = performance.now();
        trackServerTime(data.serverTime);
        if (data && Array.isArray(data.players)) {
          const nowMs = Date.now();
          const limited = data.players.slice(0, MAX_PEERS);
          limited.forEach(p => {
            if (!p.id) return;
            const existing = network.peers.get(p.id);
            const prevX = existing ? existing.x : Number(p.x) || 0;
            const prevY = existing ? existing.y : Number(p.y) || 0;
            const prevSeen = existing ? existing.lastSeen : nowMs;
            const dtSec = Math.max((nowMs - prevSeen) / 1000, 0.001);
            const speed = Math.hypot((Number(p.x) || 0) - prevX, (Number(p.y) || 0) - prevY) / dtSec;
            const speedAvg = existing ? lerp(existing.speedAvg || speed, speed, CONFIG.speedSmooth) : speed;
            const incomingPulseSeq = Number(p.pulseSeq) || 0;
            const incomingPulseAt = Number(p.pulseAt) || 0;
            const prevPulseSeq = existing ? Number(existing.pulseSeq) || 0 : 0;
            const pulseSeq = Math.max(incomingPulseSeq, prevPulseSeq);
            const pulseAt = incomingPulseAt || (existing ? existing.pulseAt : 0);
            network.peers.set(p.id, {
              id: p.id,
              x: Number(p.x) || 0,
              y: Number(p.y) || 0,
              color: p.color || '#7af6ff',
              name: p.name || 'Operateur',
              lastSeen: nowMs,
              score: Number(p.best || p.score) || 0,
              time: Number(p.bestTime || p.time) || 0,
              speed: Number.isFinite(speed) ? speed : 0,
              speedAvg: Number.isFinite(speedAvg) ? speedAvg : 0,
              pulseSeq,
              pulseAt,
              pulseAppliedSeq: existing ? (existing.pulseAppliedSeq || 0) : 0,
            });
          });
          const trimmed = Array.from(network.peers.values()).sort((a, b) => b.lastSeen - a.lastSeen);
          trimmed.slice(MAX_PEERS).forEach(p => network.peers.delete(p.id));

          if (Array.isArray(data.board)) {
            setServerBoard(data.board);
          }
          maybeUpdateBoards(true);
        }
      } catch (e) {
        network.connected = false;
      }
    }

    function spawnHazard(difficulty, waveMods = { speed: 1, size: 1 }) {
      if (state.hazards.length >= CONFIG.maxHazards) return false;
      const margin = 36;
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      if (edge === 0) { x = Math.random() * canvas.width; y = -margin; }
      else if (edge === 1) { x = canvas.width + margin; y = Math.random() * canvas.height; }
      else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + margin; }
      else { x = -margin; y = Math.random() * canvas.height; }

      const angle = Math.atan2(state.player.y - y, state.player.x - x);
      const speedBoost = (90 + difficulty * 55 + Math.random() * 80) * (waveMods.speed || 1);
      const vx = Math.cos(angle) * speedBoost;
      const vy = Math.sin(angle) * speedBoost;
      const r = (14 + Math.random() * 12) * (waveMods.size || 1);
      const shape = Array.from({ length: 7 }, () => 0.75 + Math.random() * 0.4);
      const craters = Array.from({ length: 3 + Math.floor(Math.random() * 3) }, () => ({
        a: Math.random() * Math.PI * 2,
        dist: Math.random() * 0.55 + 0.15,
        r: Math.random() * 4 + 3,
      }));
      const ttl = CONFIG.hazardTTL.min + Math.random() * CONFIG.hazardTTL.jitter;
      const hp = Math.max(1, Math.round(r / 10));
      const kind = Math.random() < 0.25 ? 'seeker' : 'drifter';
      const h = hazardPool.pop() || {};
      h.x = x;
      h.y = y;
      h.vx = vx;
      h.vy = vy;
      h.r = r;
      h.spin = (Math.random() - 0.5) * 0.8;
      h.rot = 0;
      h.shape = shape;
      h.craters = craters;
      h.ttl = ttl;
      h.hp = hp;
      h.kind = kind;
      state.hazards.push(h);
      return true;
    }

    function spawnOrb() {
      const padding = 60;
      const x = padding + Math.random() * (canvas.width - padding * 2);
      const y = padding + Math.random() * (canvas.height - padding * 2);
      state.orbs.push({
        x,
        y,
        r: 10,
        ttl: 10 + Math.random() * 6,
        rot: Math.random() * Math.PI * 2,
        spin: (Math.random() - 0.5) * 1.2,
      });
    }

    function spawnPowerup(forcedType = '') {
      const padding = 60;
      const x = padding + Math.random() * (canvas.width - padding * 2);
      const y = padding + Math.random() * (canvas.height - padding * 2);
      const allowRepair = state.integrity < state.maxIntegrity;
      const types = allowRepair ? ['slow', 'shield', 'magnet', 'repair', 'overdrive'] : ['slow', 'shield', 'magnet', 'overdrive'];
      if (allowRepair) {
        const integrityRatio = state.integrity / state.maxIntegrity;
        if (integrityRatio < 0.6) types.push('repair');
        if (integrityRatio < 0.4) types.push('repair');
      }
      const type = forcedType && types.includes(forcedType) ? forcedType : types[Math.floor(Math.random() * types.length)];
      state.powerups.push({ x, y, r: 12, ttl: 9 + Math.random() * 3, type });
    }

    function spawnFragments(x, y, count = 3) {
      const total = Math.max(1, Math.min(count, 5));
      for (let i = 0; i < total; i++) {
        const a = Math.random() * Math.PI * 2;
        const d = 8 + Math.random() * 18;
        state.orbs.push({
          x: x + Math.cos(a) * d,
          y: y + Math.sin(a) * d,
          r: 9,
          ttl: 5 + Math.random() * 3,
          rot: Math.random() * Math.PI * 2,
          spin: (Math.random() - 0.5) * 1.4,
        });
      }
    }

    const RELAY_NAMES = ['Astra', 'Vega', 'Orion', 'Lumen', 'Helia', 'Nova'];

    function randomPosition(minDist = 160) {
      const pad = 90;
      let x = pad;
      let y = pad;
      for (let i = 0; i < 12; i++) {
        x = pad + Math.random() * (canvas.width - pad * 2);
        y = pad + Math.random() * (canvas.height - pad * 2);
        if (Math.hypot(x - state.player.x, y - state.player.y) > minDist) break;
      }
      return { x, y };
    }

    function spawnRelay(index) {
      const pos = randomPosition(180);
      return {
        id: index,
        name: RELAY_NAMES[index % RELAY_NAMES.length],
        x: pos.x,
        y: pos.y,
        r: 24,
        charge: 0,
        max: CONFIG.relay.maxCharge,
        cooldown: 0,
        pulse: 0,
        pendingRelocate: false,
      };
    }

    function initRelays() {
      state.relays = Array.from({ length: CONFIG.relay.count }, (_, i) => spawnRelay(i));
      renderRelayList();
    }

    function relocateRelay(relay) {
      const pos = randomPosition(180);
      relay.x = pos.x;
      relay.y = pos.y;
      relay.charge = 0;
      relay.cooldown = 0;
      relay.pendingRelocate = false;
      relay.pulse = 0;
    }

    function surgeRelay(relay) {
      relay.charge = relay.max;
      relay.cooldown = CONFIG.relay.cooldown;
      relay.pendingRelocate = true;
      relay.pulse = 1;
      state.stats.relays += 1;
      state.score += 600 * state.multiplier;
      state.multiplier = Math.min(CONFIG.flow.max, state.multiplier + CONFIG.flow.surgeBonus);
      state.maxMultiplier = Math.max(state.maxMultiplier, state.multiplier);
      state.comboFlash = 0.5;
      addParticles(relay.x, relay.y, 'rgba(255, 209, 102, 0.9)', 32, 260);
      if (state.integrity < state.maxIntegrity) {
        state.integrity = Math.min(state.integrity + CONFIG.assist.relayRepair, state.maxIntegrity);
        addParticles(relay.x, relay.y, 'rgba(134, 242, 110, 0.6)', 18, 180);
      }

      const radius = CONFIG.relay.surgeRadius;
      for (const h of state.hazards) {
        const dist = Math.hypot(h.x - relay.x, h.y - relay.y);
        if (dist < radius) {
          h.hp = 0;
          h.ttl = 0;
        }
      }
      if (Math.random() < 0.65) spawnPowerup();
    }

    function deliverCargo(relay) {
      if (state.cargo <= 0) return;
      const units = state.cargo;
      state.cargo = 0;
      relay.charge += units * CONFIG.relay.unitCharge;
      state.stats.deliveries += units;
      state.lastDelivery = state.time;
      state.score += units * 120 * state.multiplier;
      state.multiplier = Math.min(CONFIG.flow.max, state.multiplier + units * CONFIG.flow.bump);
      state.maxMultiplier = Math.max(state.maxMultiplier, state.multiplier);
      state.comboFlash = 0.35;
      state.pulseCooldown = Math.max(0, state.pulseCooldown - units * 0.4);
      addParticles(relay.x, relay.y, 'rgba(43, 179, 166, 0.85)', 24, 200);
      if (relay.charge >= relay.max) {
        surgeRelay(relay);
      }
    }

    function updateRelays(dt) {
      for (const relay of state.relays) {
        if (relay.pulse > 0) {
          relay.pulse = Math.max(0, relay.pulse - dt * 1.4);
        }
        if (relay.cooldown > 0) {
          relay.cooldown = Math.max(0, relay.cooldown - dt);
          if (relay.cooldown === 0 && relay.pendingRelocate) {
            relocateRelay(relay);
          }
          continue;
        }
        const dx = relay.x - state.player.x;
        const dy = relay.y - state.player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < relay.r + state.player.r + 8 && state.cargo > 0) {
          deliverCargo(relay);
        }
      }
    }

    function drawRelays() {
      for (const relay of state.relays) {
        const ratio = clamp(relay.charge / relay.max, 0, 1);
        ctx.save();
        ctx.translate(relay.x, relay.y);
        ctx.beginPath();
        ctx.arc(0, 0, relay.r + 10, 0, Math.PI * 2);
        ctx.strokeStyle = relay.cooldown > 0 ? 'rgba(255,255,255,0.15)' : 'rgba(255, 209, 102, 0.25)';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(0, 0, relay.r + 6, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * ratio);
        ctx.strokeStyle = `rgba(255, 209, 102, ${0.4 + ratio * 0.4})`;
        ctx.lineWidth = 4;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(0, 0, relay.r, 0, Math.PI * 2);
        const core = ctx.createRadialGradient(0, 0, relay.r * 0.2, 0, 0, relay.r);
        core.addColorStop(0, 'rgba(255, 255, 255, 0.85)');
        core.addColorStop(1, relay.cooldown > 0 ? 'rgba(255,255,255,0.06)' : 'rgba(39, 194, 177, 0.22)');
        ctx.fillStyle = core;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        if (relay.pulse > 0) {
          const t = relay.pulse;
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.beginPath();
          ctx.arc(0, 0, relay.r + 20 + (1 - t) * 40, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(255, 209, 102, ${t * 0.5})`;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }

        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.font = '600 12px "Space Grotesk", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(relay.name, 0, 0);
        ctx.restore();
      }
    }

    function drawGuides() {
      const hasCargo = state.cargo > 0;
      const relay = hasCargo ? getClosestRelay() : null;
      const orbData = !hasCargo ? getClosestOrbData() : null;
      const target = relay || (orbData ? orbData.orb : null);
      if (!target) return;
      const dx = target.x - state.player.x;
      const dy = target.y - state.player.y;
      const dist = Math.hypot(dx, dy);
      if (dist < (hasCargo ? 120 : 140)) return;
      ctx.save();
      ctx.globalAlpha = 0.6;
      ctx.setLineDash([10, 12]);
      ctx.strokeStyle = hasCargo ? 'rgba(255, 209, 102, 0.3)' : 'rgba(43, 179, 166, 0.35)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(state.player.x, state.player.y);
      ctx.lineTo(target.x, target.y);
      ctx.stroke();
      ctx.setLineDash([]);
      const angle = Math.atan2(dy, dx);
      const tipOffset = (target.r || 10) + (hasCargo ? 18 : 12);
      const tipX = target.x - Math.cos(angle) * tipOffset;
      const tipY = target.y - Math.sin(angle) * tipOffset;
      ctx.beginPath();
      ctx.moveTo(tipX, tipY);
      ctx.lineTo(tipX - Math.cos(angle - 0.5) * 10, tipY - Math.sin(angle - 0.5) * 10);
      ctx.lineTo(tipX - Math.cos(angle + 0.5) * 10, tipY - Math.sin(angle + 0.5) * 10);
      ctx.closePath();
      ctx.fillStyle = hasCargo ? 'rgba(255, 209, 102, 0.5)' : 'rgba(43, 179, 166, 0.55)';
      ctx.fill();
      ctx.restore();
    }

    function renderRelayList() {
      if (!relayListEl) return;
      const items = state.relays.map((relay) => {
        const ratio = clamp(relay.charge / relay.max, 0, 1);
        const pct = Math.round(ratio * 100);
        const status = relay.cooldown > 0 ? `Recalage ${relay.cooldown.toFixed(1)}s` : `${pct}% charge`;
        return `
          <div class="relay-card ${relay.cooldown > 0 ? 'offline' : ''}">
            <div class="relay-title"><span>${relay.name}</span><span>${pct}%</span></div>
            <div class="relay-meter"><span style="width:${pct}%"></span></div>
            <div class="relay-note">${status}</div>
          </div>
        `;
      }).join('');
      relayListEl.innerHTML = items;
    }

    function getClosestRelay() {
      let closest = null;
      let best = Infinity;
      for (const relay of state.relays) {
        if (relay.cooldown > 0) continue;
        const dist = Math.hypot(relay.x - state.player.x, relay.y - state.player.y);
        if (dist < best) {
          best = dist;
          closest = relay;
        }
      }
      return closest;
    }

    function getClosestOrbData() {
      let closest = null;
      let best = Infinity;
      for (const orb of state.orbs) {
        const dist = Math.hypot(orb.x - state.player.x, orb.y - state.player.y);
        if (dist < best) {
          best = dist;
          closest = orb;
        }
      }
      return closest ? { orb: closest, dist: best } : null;
    }

    function isPlayerInAnomaly() {
      if (!state.anomaly.active) return false;
      const dx = state.player.x - state.anomaly.x;
      const dy = state.player.y - state.anomaly.y;
      return Math.hypot(dx, dy) <= state.anomaly.r * 0.9;
    }

    function spawnAnomaly() {
      const pos = randomPosition(220);
      state.anomaly.active = true;
      state.anomaly.x = pos.x;
      state.anomaly.y = pos.y;
      state.anomaly.r = CONFIG.anomaly.radius;
      state.anomaly.ttl = CONFIG.anomaly.duration;
      state.anomaly.glow = 1;
      state.wave.show = Math.max(state.wave.show, 1.4);
    }

    function updateAnomaly(dt) {
      if (state.anomaly.active) {
        state.anomaly.ttl = Math.max(0, state.anomaly.ttl - dt);
        state.anomaly.glow = lerp(state.anomaly.glow, 0.6, dt * 1.4);
        if (isPlayerInAnomaly()) {
          const reward = CONFIG.anomaly.rewardRate * dt * (0.9 + state.multiplier * 0.1);
          state.score += reward;
          state.multiplier = Math.min(CONFIG.flow.max, state.multiplier + dt * 0.05);
          if (state.pulseCooldown > 0) {
            state.pulseCooldown = Math.max(0, state.pulseCooldown - CONFIG.anomaly.pulseRecharge * dt);
          }
          if (Math.random() < dt * 10) {
            addParticles(state.player.x, state.player.y, 'rgba(122, 210, 255, 0.6)', 6, 120);
          }
        }
        if (state.anomaly.ttl <= 0) {
          state.anomaly.active = false;
          state.timers.anomaly = CONFIG.anomaly.cooldown;
        }
      } else {
        state.timers.anomaly -= dt;
        if (state.timers.anomaly <= 0) {
          spawnAnomaly();
        }
      }
    }

    function addParticles(x, y, color, amount = 10, speed = 120) {
      const motionScale = getMotionScale();
      const count = Math.max(1, Math.round(amount * motionScale));
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const s = Math.random() * speed * 0.6 + speed * 0.4;
        const p = particlePool.pop() || {};
        p.x = x;
        p.y = y;
        p.vx = Math.cos(a) * s;
        p.vy = Math.sin(a) * s;
        p.life = 0.5 + Math.random() * 0.4;
        p.color = color;
        p.r = 1.4 + Math.random() * 2.6;
        state.particles.push(p);
      }
    }

    function updateParticles(dt) {
      const next = [];
      for (const p of state.particles) {
        p.life -= dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.life > 0) {
          next.push(p);
        } else {
          particlePool.push(p);
        }
      }
      state.particles = next;
    }

    function updateTrail(dt) {
      state.trail = state.trail
        .map(t => ({ ...t, life: t.life - dt }))
        .filter(t => t.life > 0);
      const maxTrail = getTrailMax();
      if (state.trail.length > maxTrail) {
        state.trail.splice(0, state.trail.length - maxTrail);
      }
    }

    function triggerShake(power = 0.3) {
      if (!prefs.shake || prefs.shakeIntensity <= 0) return;
      const bump = clamp(power, 0, 1);
      state.shake.power = clamp(state.shake.power + bump, 0, 1);
    }

    function updateShake(dt) {
      if (!prefs.shake || prefs.shakeIntensity <= 0) {
        state.shake.power = 0;
        return;
      }
      if (state.shake.power > 0) {
        state.shake.power = Math.max(0, state.shake.power - dt * CONFIG.shake.decay);
      }
    }

    function getShakeOffset() {
      if (!prefs.shake || state.shake.power <= 0 || prefs.shakeIntensity <= 0) {
        return { x: 0, y: 0 };
      }
      const motionScale = getMotionScale();
      const amplitude = CONFIG.shake.max * prefs.shakeIntensity * state.shake.power * motionScale;
      return {
        x: (Math.random() * 2 - 1) * amplitude,
        y: (Math.random() * 2 - 1) * amplitude,
      };
    }

    function triggerPulse(force = false) {
      if (!state.running || state.paused) return;
      if (!force && state.pulseCooldown > 0) return;
      state.pulseActive = CONFIG.pulse.duration;
      state.pulseCooldown = CONFIG.pulse.cooldown;
      network.pulseSeq += 1;
      addParticles(state.player.x, state.player.y, 'rgba(43, 179, 166, 0.9)', 26, 220);
      triggerShake(0.22);
    }

    function triggerBoost() {
      if (!state.running || state.paused) return;
      if (state.boostCooldown > 0 || state.boostActive > 0) return;
      state.boostActive = CONFIG.boost.duration;
      state.boostCooldown = CONFIG.boost.cooldown;
      addParticles(state.player.x, state.player.y, 'rgba(140, 182, 255, 0.8)', 20, 220);
      triggerShake(0.18);
    }

    function updateStars(dt) {
      const drift = clamp(state.playerSpeedAvg / 420, 0, 1);
      for (const star of state.stars) {
        const flow = star.speed + drift * 140 * star.depth;
        star.y += flow * dt;
        star.x += Math.sin(state.time * 0.2 + star.tw) * star.depth * 6 * dt + star.drift * dt * 0.2;
        if (star.y > canvas.height + 24) {
          star.y = -24;
          star.x = Math.random() * canvas.width;
        }
        if (star.x < -40) star.x = canvas.width + 40;
        if (star.x > canvas.width + 40) star.x = -40;
      }
    }

    function updatePlayer(dt) {
      const moving = input.up || input.down || input.left || input.right || touchInput.up || touchInput.down || touchInput.left || touchInput.right;
      const targetThrust = moving ? 1 : 0;
      const ramp = moving ? 2.8 : 3.8; // montee/descente plus lente
      state.thrust = clamp(state.thrust + (targetThrust - state.thrust) * ramp * dt, 0, 1);

      let ix = 0, iy = 0;
      if (input.up || touchInput.up) iy -= 1;
      if (input.down || touchInput.down) iy += 1;
      if (input.left || touchInput.left) ix -= 1;
      if (input.right || touchInput.right) ix += 1;
      const mag = Math.hypot(ix, iy);
      if (mag > 0) {
        ix /= mag;
        iy /= mag;
      }

      const overdriveBoost = state.effects.overdrive > 0 ? 1.18 : 1;
      const burstBoost = state.boostActive > 0 ? CONFIG.boost.multiplier : 1;
      const targetSpeed = lerp(90, 440, state.thrust) * overdriveBoost * burstBoost; // limite haute reduite
      const accelLerp = lerp(3.5, 7.5, state.thrust) * (state.effects.overdrive > 0 ? 1.2 : 1.05) * (state.boostActive > 0 ? 1.2 : 1); // interpolation plus douce
      state.player.vx = lerp(state.player.vx, ix * targetSpeed, accelLerp * dt);
      state.player.vy = lerp(state.player.vy, iy * targetSpeed, accelLerp * dt);

      const decay = Math.pow(moving ? 0.994 : 0.94, dt * 60) * (state.effects.overdrive > 0 ? 0.992 : 1) * (state.boostActive > 0 ? 0.992 : 1);
      state.player.vx *= decay;
      state.player.vy *= decay;

      state.player.x = clamp(state.player.x + state.player.vx * dt, state.player.r, canvas.width - state.player.r);
      state.player.y = clamp(state.player.y + state.player.vy * dt, state.player.r, canvas.height - state.player.r);

      // ajoute une trace neon selon l impulsion actuelle
      const speedMag = Math.hypot(state.player.vx, state.player.vy);
      const life = CONFIG.trail.baseLife + clamp(speedMag / 420, 0, 1) * CONFIG.trail.speedLife;
      if (Math.random() < getMotionScale()) {
        state.trail.push({ x: state.player.x, y: state.player.y, life, r: state.player.r });
      }

      state.playerSpeedAvg = lerp(state.playerSpeedAvg, speedMag, CONFIG.speedSmooth);
    }

    function updateHazards(dt, difficulty) {
      const slowFactor = state.effects.slow > 0 ? 0.6 : (state.assistSlow > 0 ? 0.82 : 1);
      const effectiveDt = dt * slowFactor;

      state.hazards.forEach(h => {
        h.ttl -= dt;
        if (h.kind === 'seeker') {
          const dx = state.player.x - h.x;
          const dy = state.player.y - h.y;
          const dist = Math.hypot(dx, dy) || 1;
          const pull = 16 + difficulty * 6;
          h.vx += (dx / dist) * pull * effectiveDt;
          h.vy += (dy / dist) * pull * effectiveDt;
        }
        h.x += h.vx * effectiveDt;
        h.y += h.vy * effectiveDt;
        h.rot += h.spin * effectiveDt;

        h.vx += (Math.random() - 0.5) * 16 * effectiveDt;
        h.vy += (Math.random() - 0.5) * 16 * effectiveDt;

        if (h.x < h.r) { h.x = h.r; h.vx *= -1; }
        if (h.x > canvas.width - h.r) { h.x = canvas.width - h.r; h.vx *= -1; }
        if (h.y < h.r) { h.y = h.r; h.vy *= -1; }
        if (h.y > canvas.height - h.r) { h.y = canvas.height - h.r; h.vy *= -1; }
      });

      if (state.pulseActive > 0) {
        for (const h of state.hazards) {
          const dx = h.x - state.player.x;
          const dy = h.y - state.player.y;
          const dist = Math.hypot(dx, dy) || 0.001;
          const reach = CONFIG.pulse.reach;
          if (dist < reach) {
            const force = (1 - dist / reach) * CONFIG.pulse.force;
            h.vx += (dx / dist) * force * dt;
            h.vy += (dy / dist) * force * dt;
            const blastKill = reach * CONFIG.pulse.destroyRatio;
            if (dist < blastKill) {
              h.hp = (h.hp || 1) - 1;
              if (h.hp <= 0) {
                h.ttl = 0;
                addParticles(h.x, h.y, 'rgba(255, 149, 90, 0.8)', 22, 240);
                continue;
              }
            }
          }
        }
        state.pulseActive -= dt;
      }

      for (const h of state.hazards) {
        if (h.hp <= 0) continue;
        const dx = h.x - state.player.x;
        const dy = h.y - state.player.y;
        const dist2 = dx * dx + dy * dy;
        const rad = (h.r + state.player.r) ** 2;
        if (dist2 < rad && state.running && !state.paused) {
          const dist = Math.hypot(dx, dy) || 1;
          if (state.effects.shield > 0 && state.shieldCharges > 0) {
            state.shieldCharges -= 1;
            if (state.shieldCharges <= 0) state.effects.shield = 0;
            addParticles(state.player.x, state.player.y, 'rgba(134, 242, 110, 0.8)', 26, 240);
            triggerShake(0.24);
            h.x += Math.sign(dx || 1) * (h.r + 8);
            h.y += Math.sign(dy || 1) * (h.r + 8);
            // renvoyer le bloc a l oppose
            const speed = Math.hypot(h.vx, h.vy) || (120 + Math.random() * 80);
            h.vx = (dx / dist) * speed;
            h.vy = (dy / dist) * speed;
            triggerPulse(true);
            continue;
          }
          const damage = Math.max(14, Math.round(CONFIG.integrity.hit + (h.r - 14)));
          state.integrity = Math.max(0, state.integrity - damage);
          state.stats.hits += 1;
          state.multiplier = Math.max(1, state.multiplier - 0.35);
          state.assistSlow = Math.max(state.assistSlow, CONFIG.assist.hitSlow);
          addParticles(state.player.x, state.player.y, 'rgba(214, 69, 80, 0.9)', 28, 260);
          triggerShake(0.52);
          h.x += Math.sign(dx || 1) * (h.r + 8);
          h.y += Math.sign(dy || 1) * (h.r + 8);
          const speed = Math.hypot(h.vx, h.vy) || (120 + Math.random() * 80);
          h.vx = (dx / dist) * speed;
          h.vy = (dy / dist) * speed;
          triggerPulse(true);
          if (state.integrity <= 0) {
            endGame();
          }
        }
      }

      const remaining = [];
      for (const h of state.hazards) {
        const destroyed = h.hp !== undefined && h.hp <= 0;
        if (h.ttl > 0 && !destroyed) {
          remaining.push(h);
        } else {
          if (destroyed) {
            spawnFragments(h.x, h.y, 2 + Math.floor(Math.random() * 2));
          }
          hazardPool.push(h);
        }
      }
      state.hazards = remaining;
    }

    function updateOrbs(dt) {
      const magnet = state.effects.magnet > 0;
      state.orbs.forEach(o => {
        o.ttl -= dt;
        o.rot = (o.rot || 0) + (o.spin || 0) * dt;
        if (magnet) {
          const dx = state.player.x - o.x;
          const dy = state.player.y - o.y;
          const dist = Math.hypot(dx, dy) || 1;
          const reach = CONFIG.magnetReach;
          if (dist < reach) {
            const pull = (1 - dist / reach) * 180;
            o.x += (dx / dist) * pull * dt;
            o.y += (dy / dist) * pull * dt;
          }
        }
      });
      state.orbs = state.orbs.filter(o => o.ttl > 0);

      for (let i = state.orbs.length - 1; i >= 0; i--) {
        const o = state.orbs[i];
        const dx = o.x - state.player.x;
        const dy = o.y - state.player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < o.r + state.player.r + 2) {
          state.orbs.splice(i, 1);
          if (state.cargo < state.maxCargo) {
            state.cargo += 1;
            state.stats.cores += 1;
            state.score += 20;
            addParticles(o.x, o.y, 'rgba(43, 179, 166, 0.9)', 18, 200);
          } else {
            state.score += 35 * state.multiplier;
            addParticles(o.x, o.y, 'rgba(255, 209, 102, 0.9)', 16, 180);
          }
        }
      }
    }

    function applyPeerPulseEffects(dt) {
      const serverNow = getServerNow();
      if (!serverNow) return;
      const reach = CONFIG.pulse.reach * 0.9;
      for (const peer of network.peers.values()) {
        const pulseSeq = peer.pulseSeq || 0;
        if (!pulseSeq || peer.pulseAppliedSeq === pulseSeq) continue;
        const pulseAt = peer.pulseAt || 0;
        const age = serverNow - pulseAt;
        if (age < 0 || age > CONFIG.pulse.duration) continue;
        const dx = state.player.x - peer.x;
        const dy = state.player.y - peer.y;
        const dist = Math.hypot(dx, dy) || 0.001;
        if (dist < reach) {
          const force = (1 - dist / reach) * CONFIG.pulse.force * 0.35;
          state.player.vx += (dx / dist) * force * dt;
          state.player.vy += (dy / dist) * force * dt;
        }
        peer.pulseAppliedSeq = pulseSeq;
      }
    }

    function checkPeerCollisions() {
      if (state.hitCooldown > 0 || network.peers.size === 0) return;
      for (const peer of network.peers.values()) {
        const dx = peer.x - state.player.x;
        const dy = peer.y - state.player.y;
        const rad = 12 + state.player.r;
        if (dx * dx + dy * dy < rad * rad) {
          const playerSpeed = state.playerSpeedAvg || 0;
          const peerSpeed = peer.speedAvg || peer.speed || 0;
          const slowerIsPlayer = playerSpeed + CONFIG.speedMargin < peerSpeed;

          if (slowerIsPlayer) {
            if (state.effects.shield > 0 && state.shieldCharges > 0) {
              state.shieldCharges -= 1;
              if (state.shieldCharges <= 0) state.effects.shield = 0;
              addParticles(state.player.x, state.player.y, 'rgba(134, 242, 110, 0.8)', 26, 240);
            } else {
              const damage = Math.round(CONFIG.integrity.hit * 0.75);
              state.integrity = Math.max(0, state.integrity - damage);
              state.stats.hits += 1;
              state.multiplier = Math.max(1, state.multiplier - 0.25);
              state.assistSlow = Math.max(state.assistSlow, CONFIG.assist.hitSlow);
              addParticles(state.player.x, state.player.y, 'rgba(214, 69, 80, 0.9)', 24, 200);
              if (state.integrity <= 0) {
                endGame();
                return;
              }
            }
          } else {
            addParticles(state.player.x, state.player.y, 'rgba(43, 179, 166, 0.7)', 18, 160);
          }

          triggerPulse(true);
          triggerShake(0.32);
          // repousse legerement le joueur
          const dist = Math.hypot(dx, dy) || 1;
          state.player.x -= (dx / dist) * 12;
          state.player.y -= (dy / dist) * 12;
          state.hitCooldown = 0.6;
          break;
        }
      }
    }

    function applyPowerup(type) {
      if (type === 'slow') state.effects.slow = CONFIG.powerups.slow;
      if (type === 'shield') {
        state.shieldCharges += 1;
        state.effects.shield = (state.effects.shield || 0) + CONFIG.powerups.shield;
      }
      if (type === 'magnet') state.effects.magnet = CONFIG.powerups.magnet;
      if (type === 'overdrive') {
        state.effects.overdrive = CONFIG.powerups.overdrive;
        state.multiplier = Math.min(state.multiplier + 0.3, CONFIG.flow.max);
        state.maxMultiplier = Math.max(state.maxMultiplier, state.multiplier);
        state.pulseCooldown = Math.max(0, state.pulseCooldown - 0.8);
      }
      if (type === 'repair') {
        state.integrity = Math.min(state.integrity + 28, state.maxIntegrity);
      }
      const colors = {
        slow: 'rgba(43, 179, 166, 0.7)',
        shield: 'rgba(134, 242, 110, 0.8)',
        magnet: 'rgba(255, 149, 90, 0.8)',
        repair: 'rgba(255, 209, 102, 0.9)',
        overdrive: 'rgba(255, 221, 115, 0.88)',
      };
      addParticles(state.player.x, state.player.y, colors[type] || 'rgba(43, 179, 166, 0.8)', 24, 180);
      triggerShake(0.18);
    }

    function updatePowerups(dt) {
      for (const p of state.powerups) p.ttl -= dt;
      state.powerups = state.powerups.filter(p => p.ttl > 0);

      for (let i = state.powerups.length - 1; i >= 0; i--) {
        const p = state.powerups[i];
        const dx = p.x - state.player.x;
        const dy = p.y - state.player.y;
        const dist = Math.hypot(dx, dy);
        if (dist < p.r + state.player.r + 4) {
          applyPowerup(p.type);
          state.powerups.splice(i, 1);
        }
      }
    }

    function updateEffects(dt) {
      for (const key of Object.keys(state.effects)) {
        if (state.effects[key] > 0) state.effects[key] -= dt;
        if (state.effects[key] < 0) state.effects[key] = 0;
      }
      if (state.effects.shield <= 0) state.shieldCharges = 0;
      if (state.boostActive > 0) {
        state.boostActive = Math.max(0, state.boostActive - dt);
        if (Math.random() < dt * 12) {
          addParticles(state.player.x, state.player.y, 'rgba(140, 182, 255, 0.6)', 8, 160);
        }
      }
      if (state.boostCooldown > 0) state.boostCooldown = Math.max(0, state.boostCooldown - dt);
      if (state.effects.overdrive > 0 && state.pulseCooldown > 0) {
        state.pulseCooldown = Math.max(0, state.pulseCooldown - dt * 0.9);
      }
      if (state.assistSlow > 0) state.assistSlow -= dt;
      if (state.assistSlow < 0) state.assistSlow = 0;
      if (state.hitCooldown > 0) state.hitCooldown -= dt;
      if (state.hitCooldown < 0) state.hitCooldown = 0;
      updateShake(dt);
    }

    function updateUI() {
      scoreEl.textContent = Math.floor(state.score);
      flowEl.textContent = `x${state.multiplier.toFixed(1)}`;
      timeEl.textContent = formatTime(state.time);
      if (integrityLabel && integrityFill) {
        const pct = Math.round((state.integrity / state.maxIntegrity) * 100);
        integrityLabel.textContent = `${pct}%`;
        integrityFill.style.width = `${pct}%`;
      }
      if (cargoEl) {
        cargoEl.textContent = `${state.cargo}/${state.maxCargo}`;
      }
      if (objectiveLabelEl && objectiveBadge) {
        const integrityRatio = state.integrity / state.maxIntegrity;
        const objectiveDanger = state.danger || computeDanger();
        let label = 'Collecte';
        let note = 'Ramasse les noyaux';
        let mode = '';
        if (integrityRatio <= 0.35) {
          label = 'Reparer';
          note = 'Trouve un module reparation';
          mode = 'urgent';
        } else if (state.cargo >= state.maxCargo) {
          label = 'Livrer';
          const closest = getClosestRelay();
          note = closest ? `Vers relais ${closest.name}` : 'Cherche un relais';
        } else if (state.cargo > 0) {
          label = 'Livrer';
          const closest = getClosestRelay();
          note = closest ? `Relais ${closest.name} en vue` : 'Rejoins un relais';
        } else if (state.anomaly.active && !isPlayerInAnomaly()) {
          label = 'Anomalie';
          note = `Zone a ${Math.round(Math.hypot(state.anomaly.x - state.player.x, state.anomaly.y - state.player.y))}m`;
        } else if (state.pulseCooldown <= 0 && objectiveDanger.level === 'high') {
          label = 'Onde';
          note = 'Appuie sur Espace';
          mode = 'pulse';
        } else {
          const orbData = getClosestOrbData();
          if (orbData) {
            note = `Noyau a ${Math.round(orbData.dist)}m`;
          } else {
            note = 'Patrouille la zone';
          }
        }
        objectiveLabelEl.textContent = label;
        if (objectiveNoteEl) objectiveNoteEl.textContent = note;
        objectiveBadge.classList.toggle('is-urgent', mode === 'urgent');
        objectiveBadge.classList.toggle('is-pulse', mode === 'pulse');
      }
      bestEl.textContent = Math.floor(state.serverBest || 0);
      if (bestPlayerEl) {
        const who = state.serverBestName || '';
        const t = state.serverBestTime ? formatClock(state.serverBestTime) : '';
        bestPlayerEl.textContent = who && t ? `${who} • ${t}` : (who || t || '');
      }
      pulseEl.textContent = state.pulseCooldown <= 0 ? 'Pret' : `${state.pulseCooldown.toFixed(1)}s`;
      if (boostEl && boostBadge) {
        boostEl.textContent = state.boostCooldown <= 0 ? 'Pret' : `${state.boostCooldown.toFixed(1)}s`;
        boostBadge.classList.toggle('is-ready', state.boostCooldown <= 0);
      }

      if (peerTopEl && peerTopScoreEl) {
        const selfName = getSelfLeaderboardName();
        const candidates = [
          { name: selfName, score: state.sessionBest || 0, time: state.sessionBestTime || 0 },
          ...Array.from(network.peers.values()).map(p => ({ name: p.name || 'Operateur', score: p.score || 0, time: p.time || 0 })),
        ];
        const top = [...candidates].sort((a, b) => (b.score || 0) - (a.score || 0) || (b.time || 0) - (a.time || 0))[0];
        if (top && network.peers.size) {
          peerTopEl.textContent = top.name || 'Operateur';
          peerTopScoreEl.textContent = top.score ? `${Math.floor(top.score)} pts` : '';
        } else {
          peerTopEl.textContent = 'Solo';
          peerTopScoreEl.textContent = '';
        }
      }
      if (netStatusEl) {
        const idle = performance.now() - (network.lastSuccessAt || 0);
        const online = network.connected && idle < CONFIG.net.heartbeat * 4;
        netStatusEl.textContent = online ? `${Math.round(network.latencyMs || 0)}ms` : 'Hors ligne';
      }
      if (dangerEl && dangerBadge) {
        const danger = state.danger || computeDanger();
        let label = 'Calme';
        let cls = 'danger-low';
        if (danger.level === 'med') { label = 'Pression'; cls = 'danger-med'; }
        if (danger.level === 'high') { label = 'Tempete'; cls = 'danger-high'; }
        dangerEl.textContent = label;
        dangerBadge.classList.remove('danger-low', 'danger-med', 'danger-high');
        dangerBadge.classList.add(cls);
      }

      if (relayFocusEl) {
        const closest = getClosestRelay();
        if (closest) {
          relayFocusEl.textContent = closest.name;
          if (relayHintEl) {
            relayHintEl.textContent = `${Math.round(closest.charge)}% charge`;
          }
        } else {
          relayFocusEl.textContent = 'Aucun';
          if (relayHintEl) relayHintEl.textContent = '';
        }
      }

      if (waveLabelEl) {
        if (state.wave.active && state.wave.profile) {
          const timeLeft = Math.max(0, Math.ceil(state.wave.timeLeft || 0));
          const name = state.wave.profile.name || 'Front';
          waveLabelEl.textContent = `${name} ${timeLeft}s`;
        } else {
          waveLabelEl.textContent = 'Accalmie';
        }
      }
      if (waveBadge) {
        waveBadge.classList.toggle('wave-active', state.wave.active);
      }
      if (waveBanner) {
        const showWave = state.wave.show > 0 && state.wave.profile;
        const showAnomaly = state.anomaly.active;
        let bannerText = '';
        if (showAnomaly) {
          bannerText = `Anomalie de flux • ${Math.max(1, Math.ceil(state.anomaly.ttl))}s`;
        } else if (showWave) {
          const reward = state.wave.profile.reward ? POWERUP_LABELS[state.wave.profile.reward] : '';
          bannerText = reward ? `Front: ${state.wave.profile.name} - Module: ${reward}` : `Front: ${state.wave.profile.name}`;
        }
        if (bannerText) waveBanner.textContent = bannerText;
        waveBanner.classList.toggle('hidden', !(showWave || showAnomaly));
      }

      const effects = [];
      if (state.effects.slow > 0) effects.push('Stase');
      if (state.assistSlow > 0) effects.push('Stabilisation');
      if (state.effects.shield > 0 && state.shieldCharges > 0) {
        const shieldLabel = state.shieldCharges > 1 ? `Phase x${state.shieldCharges}` : 'Phase';
        effects.push(shieldLabel);
      }
      if (state.effects.magnet > 0) effects.push('Aimant');
      if (state.effects.overdrive > 0) effects.push('Turbo');
      effectsEl.textContent = effects.length ? `Modules: ${effects.join(' | ')}` : 'Modules: aucun';

      if (state.comboFlash > 0) {
        flowBadge.style.transform = 'scale(1.06)';
        flowBadge.style.boxShadow = '0 0 16px rgba(43, 179, 166, 0.6)';
      } else {
        flowBadge.style.transform = 'scale(1)';
        flowBadge.style.boxShadow = 'none';
      }

      renderRelayList();
      maybeUpdateBoards();
    }

    function drawBackground() {
      ctx.drawImage(bgCanvas, 0, 0);

      const drift = clamp(state.playerSpeedAvg / 420, 0, 1);

      // grille douce pour donner du relief
      ctx.save();
      ctx.globalAlpha = 0.05 + drift * 0.06;
      ctx.strokeStyle = 'rgba(120, 210, 220, 0.35)';
      ctx.lineWidth = 1;
      const step = 120;
      for (let x = (state.time * 18) % step; x < canvas.width + step; x += step) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x - 36, canvas.height);
        ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(255, 187, 122, 0.28)';
      for (let y = (state.time * 12) % step; y < canvas.height + step; y += step) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y - 30);
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const s of state.stars) {
        const twinkle = 0.65 + Math.sin(state.time * 1.2 + s.tw) * 0.25;
        const alpha = (0.18 + s.depth * 0.5) * twinkle;
        ctx.fillStyle = `hsla(${s.hue}, 80%, 88%, ${alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.s, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawAnomaly() {
      if (!state.anomaly.active) return;
      const t = state.time * 1.2;
      const pulse = 0.75 + Math.sin(t) * 0.15;
      const radius = state.anomaly.r * pulse;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createRadialGradient(
        state.anomaly.x, state.anomaly.y, radius * 0.2,
        state.anomaly.x, state.anomaly.y, radius * 1.2
      );
      g.addColorStop(0, 'rgba(122, 210, 255, 0.35)');
      g.addColorStop(0.55, 'rgba(62, 160, 220, 0.18)');
      g.addColorStop(1, 'rgba(20, 40, 80, 0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(state.anomaly.x, state.anomaly.y, radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = `rgba(122, 210, 255, ${0.28 + state.anomaly.glow * 0.2})`;
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 14]);
      ctx.beginPath();
      ctx.arc(state.anomaly.x, state.anomaly.y, radius * 0.9, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    function drawShip(entity, color, hasShield = false, pulseActive = 0, name = '', thrust = 0) {
      const p = entity;
      const angle = Math.atan2(p.vy, p.vx) || -Math.PI / 2;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(angle + Math.PI / 2);

      ctx.beginPath();
      ctx.arc(0, 0, p.r + 7, 0, Math.PI * 2);
      const glow = color.replace('hsl', 'hsla').replace(')', ', 0.55)');
      ctx.strokeStyle = glow;
      ctx.lineWidth = 2.5;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, -p.r - 3);
      ctx.lineTo(p.r * 1.02, p.r * 0.9);
      ctx.lineTo(0, p.r * 0.4);
      ctx.lineTo(-p.r * 1.02, p.r * 0.9);
      ctx.closePath();
      const body = ctx.createLinearGradient(-p.r, -p.r, p.r, p.r * 1.2);
      body.addColorStop(0, color.replace('hsl', 'hsla').replace(')', ', 0.95)'));
      body.addColorStop(1, 'rgba(8, 12, 20, 0.9)');
      ctx.fillStyle = body;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      ctx.ellipse(0, -p.r * 0.2, p.r * 0.32, p.r * 0.55, 0, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
      ctx.strokeStyle = 'rgba(8, 12, 20, 0.55)';
      ctx.lineWidth = 1;
      ctx.fill();
      ctx.stroke();

      const thrustPower = clamp(thrust, 0, 1);
      if (thrustPower > 0.05) {
        const flicker = 0.6 + Math.random() * 0.4;
        const flameLen = p.r * (1.1 + thrustPower * 1.6) * flicker;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const flame = ctx.createRadialGradient(0, p.r * 0.9, 2, 0, p.r * 1.1 + flameLen, p.r * 2.2 + flameLen);
        flame.addColorStop(0, 'rgba(255, 238, 180, 0.95)');
        flame.addColorStop(0.35, 'rgba(255, 174, 96, 0.75)');
        flame.addColorStop(1, 'rgba(255, 116, 90, 0)');
        ctx.fillStyle = flame;
        ctx.beginPath();
        ctx.moveTo(-p.r * 0.45, p.r * 0.9);
        ctx.lineTo(0, p.r * 1.3 + flameLen);
        ctx.lineTo(p.r * 0.45, p.r * 0.9);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      if (hasShield) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(0, 0, p.r + 14, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(134, 242, 110, 0.75)';
        ctx.lineWidth = 2.5;
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();

      if (name) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.font = '700 13px "Space Grotesk", "Trebuchet MS", sans-serif';
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillText(name, -ctx.measureText(name).width / 2 + 1, -p.r - 18 + 1);
        ctx.fillStyle = '#e7f1ff';
        ctx.fillText(name, -ctx.measureText(name).width / 2, -p.r - 18);
        ctx.restore();
      }

      if (pulseActive > 0) {
        const t = pulseActive / CONFIG.pulse.duration;
        const radius = (1 - t) * 150 + 40;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(43, 179, 166, ${t * 0.6})`;
        ctx.lineWidth = 4;
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawPlayer() {
      const danger = state.danger || computeDanger();
      if (danger && danger.level !== 'low') {
        const color = danger.level === 'high' ? '255, 94, 123' : '255, 149, 90';
        const dangerFactor = clamp((260 - (danger.nearest || 999)) / 260 + (danger.density || 0), 0, 1);
        const radius = state.player.r + 22 + dangerFactor * 16;
        const alpha = 0.14 + dangerFactor * 0.32;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(state.player.x, state.player.y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${color}, ${alpha})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 10]);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.arc(state.player.x, state.player.y, radius * 0.72, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${color}, ${alpha * 0.4})`;
        ctx.fill();
        ctx.restore();
      }

      const pulseRatio = clamp(1 - (state.pulseCooldown / CONFIG.pulse.cooldown), 0, 1);
      ctx.save();
      ctx.beginPath();
      ctx.arc(state.player.x, state.player.y, state.player.r + 20, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      ctx.lineWidth = 2;
      ctx.stroke();
      if (pulseRatio > 0) {
        ctx.beginPath();
        ctx.arc(state.player.x, state.player.y, state.player.r + 20, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * pulseRatio);
        ctx.strokeStyle = `rgba(39, 194, 177, ${0.2 + pulseRatio * 0.45})`;
        ctx.lineWidth = 2.4;
        ctx.stroke();
      }
      ctx.restore();

      const hasShield = state.effects.shield > 0 && state.shieldCharges > 0;
      drawShip(state.player, state.color, hasShield, state.pulseActive, state.name, state.thrust);
      if (state.effects.overdrive > 0) {
        const t = clamp(state.effects.overdrive / CONFIG.powerups.overdrive, 0, 1);
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(state.player.x, state.player.y, state.player.r + 18, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 221, 115, ${0.35 + 0.25 * t})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 8]);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }
    }

    function drawPeers() {
      for (const peer of network.peers.values()) {
        const ghost = { x: peer.x, y: peer.y, vx: 0, vy: 0, r: 12 };
        const labelScore = peer.score ? ` • ${Math.floor(peer.score)}` : '';
        const thrust = clamp((peer.speedAvg || 0) / 260, 0.15, 0.85);
        drawShip(ghost, peer.color, false, 0, `${peer.name}${labelScore}`, thrust);
      }
    }

    function drawPeerPulses() {
      const serverNow = getServerNow();
      if (!serverNow) return;
      for (const peer of network.peers.values()) {
        const pulseAt = peer.pulseAt || 0;
        if (!pulseAt) continue;
        const age = serverNow - pulseAt;
        if (age < 0 || age > CONFIG.pulse.duration) continue;
        const t = clamp(age / CONFIG.pulse.duration, 0, 1);
        const radius = CONFIG.pulse.reach * t;
        const alpha = (1 - t) * 0.35;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(peer.x, peer.y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(43, 179, 166, ${alpha})`;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawHazards() {
      for (const h of state.hazards) {
        const speed = Math.hypot(h.vx, h.vy);
        if (speed > 120) {
          const streak = Math.min(70, 18 + speed * 0.12);
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.strokeStyle = h.kind === 'seeker' ? 'rgba(72, 200, 190, 0.25)' : 'rgba(255, 166, 110, 0.22)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(h.x, h.y);
          ctx.lineTo(h.x - (h.vx / speed) * streak, h.y - (h.vy / speed) * streak);
          ctx.stroke();
          ctx.restore();
        }
        ctx.save();
        ctx.translate(h.x, h.y);
        ctx.rotate(h.rot);
        ctx.beginPath();
        const sides = h.shape ? h.shape.length : 6;
        for (let i = 0; i < sides; i++) {
          const a = (i / sides) * Math.PI * 2;
          const radial = h.shape ? h.r * h.shape[i] : h.r;
          const rx = Math.cos(a) * radial;
          const ry = Math.sin(a) * radial;
          if (i === 0) ctx.moveTo(rx, ry);
          else ctx.lineTo(rx, ry);
        }
        ctx.closePath();
        const g = ctx.createRadialGradient(0, 0, h.r * 0.15, 0, 0, h.r);
        const core = h.kind === 'seeker' ? 'rgba(72, 200, 190, 0.92)' : 'rgba(255, 186, 120, 0.92)';
        const shell = h.kind === 'seeker' ? 'rgba(18, 54, 58, 0.95)' : 'rgba(93, 60, 35, 0.92)';
        g.addColorStop(0, core);
        g.addColorStop(1, shell);
        ctx.fillStyle = g;
        ctx.strokeStyle = h.kind === 'seeker' ? 'rgba(43, 179, 166, 0.5)' : 'rgba(242, 143, 59, 0.45)';
        ctx.lineWidth = 1.4;
        ctx.fill();
        ctx.stroke();

        // cratères pour un look météorite
        if (h.craters) {
          for (const c of h.craters) {
            const cx = Math.cos(c.a) * h.r * c.dist;
            const cy = Math.sin(c.a) * h.r * c.dist;
            ctx.beginPath();
            ctx.arc(cx, cy, c.r, 0, Math.PI * 2);
            ctx.fillStyle = h.kind === 'seeker' ? 'rgba(8, 28, 30, 0.7)' : 'rgba(38, 22, 12, 0.65)';
            ctx.fill();
            ctx.strokeStyle = h.kind === 'seeker' ? 'rgba(157, 255, 234, 0.25)' : 'rgba(255, 210, 160, 0.25)';
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        }

        // reflet discret
        ctx.globalCompositeOperation = 'lighter';
        ctx.strokeStyle = h.kind === 'seeker' ? 'rgba(72, 200, 190, 0.2)' : 'rgba(255, 204, 128, 0.16)';
        ctx.lineWidth = 1.2;
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();
      }
    }

    function drawOrbs() {
      for (const o of state.orbs) {
        const blink = 0.5 + Math.sin((10 - o.ttl) * 4) * 0.12;
        const r = o.r * (1 + blink * 0.08);
        ctx.save();
        ctx.translate(o.x, o.y);
        ctx.rotate(o.rot || 0);
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(0, 0, r * 2.1, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(43, 179, 166, ${0.08 + blink * 0.12})`;
        ctx.fill();
        ctx.restore();
        const g = ctx.createRadialGradient(0, 0, 0, 0, 0, r * 1.8);
        g.addColorStop(0, 'rgba(43, 179, 166, 0.95)');
        g.addColorStop(1, 'rgba(255, 209, 102, 0.12)');
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const a = (i / 6) * Math.PI * 2;
          const rx = Math.cos(a) * r;
          const ry = Math.sin(a) * r;
          if (i === 0) ctx.moveTo(rx, ry);
          else ctx.lineTo(rx, ry);
        }
        ctx.closePath();
        ctx.fillStyle = g;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(0, 0, r * 1.6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(39, 194, 177, 0.25)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.restore();
        ctx.restore();
      }
    }

    function drawPowerups() {
      for (const p of state.powerups) {
        const colors = { slow: '#7ad2ff', shield: '#86f26e', magnet: '#ff955a', repair: '#ffd166', overdrive: '#ffd773' };
        const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r * 1.65);
        g.addColorStop(0, colors[p.type] || '#7af6ff');
        g.addColorStop(1, 'rgba(255,255,255,0.08)');
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fillStyle = g;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
        ctx.lineWidth = 1.2;
        ctx.stroke();
        const pulse = 0.6 + Math.sin(state.time * 2.6 + p.x * 0.01 + p.y * 0.01) * 0.4;
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * (1.5 + pulse * 0.4), 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${0.12 + pulse * 0.18})`;
        ctx.lineWidth = 1.4;
        ctx.stroke();
        ctx.restore();

        // pictogramme net selon le type
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.lineWidth = 1.6;
        ctx.strokeStyle = 'rgba(5, 9, 20, 0.58)';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.82)';
        ctx.beginPath();
        if (p.type === 'shield') {
          ctx.moveTo(0, -p.r * 0.65);
          ctx.lineTo(p.r * 0.55, -p.r * 0.15);
          ctx.lineTo(p.r * 0.38, p.r * 0.55);
          ctx.quadraticCurveTo(0, p.r * 0.8, -p.r * 0.38, p.r * 0.55);
          ctx.lineTo(-p.r * 0.55, -p.r * 0.15);
          ctx.closePath();
          ctx.stroke();
          ctx.fill();
        } else if (p.type === 'slow') {
          ctx.moveTo(-p.r * 0.45, -p.r * 0.5);
          ctx.lineTo(p.r * 0.45, -p.r * 0.15);
          ctx.lineTo(-p.r * 0.45, p.r * 0.2);
          ctx.lineTo(p.r * 0.45, p.r * 0.55);
          ctx.stroke();
        } else if (p.type === 'magnet') {
          ctx.beginPath();
          ctx.moveTo(-p.r * 0.55, -p.r * 0.5);
          ctx.arc(-p.r * 0.2, -p.r * 0.5, p.r * 0.35, Math.PI, Math.PI * 1.5);
          ctx.lineTo(p.r * 0.2, -p.r * 0.85);
          ctx.arc(p.r * 0.2, -p.r * 0.5, p.r * 0.35, Math.PI * 1.5, 0);
          ctx.lineTo(p.r * 0.55, p.r * 0.2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(-p.r * 0.55, p.r * 0.35);
          ctx.lineTo(-p.r * 0.2, p.r * 0.35);
          ctx.moveTo(p.r * 0.2, p.r * 0.35);
          ctx.lineTo(p.r * 0.55, p.r * 0.35);
          ctx.stroke();
        } else if (p.type === 'repair') {
          const r = p.r * 0.55;
          ctx.moveTo(0, r * 0.9);
          ctx.bezierCurveTo(r * 0.9, r * 0.4, r * 0.9, -r * 0.3, 0, -r * 0.1);
          ctx.bezierCurveTo(-r * 0.9, -r * 0.3, -r * 0.9, r * 0.4, 0, r * 0.9);
          ctx.fill();
          ctx.stroke();
        } else if (p.type === 'overdrive') {
          ctx.beginPath();
          ctx.moveTo(-p.r * 0.2, -p.r * 0.7);
          ctx.lineTo(p.r * 0.1, -p.r * 0.1);
          ctx.lineTo(-p.r * 0.25, -p.r * 0.1);
          ctx.lineTo(p.r * 0.2, p.r * 0.75);
          ctx.lineTo(-p.r * 0.05, p.r * 0.15);
          ctx.lineTo(p.r * 0.25, p.r * 0.15);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }
        ctx.restore();
      }
    }

    function drawParticles() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const p of state.particles) {
        const alpha = Math.max(p.life * 1.8, 0);
        const r = (p.r || 2) * (1 + (1 - p.life) * 0.6);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawTrail() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for (const t of state.trail) {
        const alpha = clamp(t.life / 0.45, 0, 1) * 0.45;
        const radius = (t.r || 12) * (1 + (1 - t.life) * 0.6);
        const g = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, radius * 1.6);
        g.addColorStop(0, state.color.replace('hsl', 'hsla').replace(')', `, ${alpha})`));
        g.addColorStop(1, 'rgba(43, 179, 166, 0)');
        ctx.beginPath();
        ctx.arc(t.x, t.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = g;
        ctx.fill();
        if (state.effects.overdrive > 0) {
          const halo = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, radius * 1.2);
          halo.addColorStop(0, `rgba(255, 221, 115, ${alpha * 0.9})`);
          halo.addColorStop(1, 'rgba(255, 221, 115, 0)');
          ctx.fillStyle = halo;
          ctx.fill();
        }
      }
      ctx.restore();
    }

    function gameStep(dt) {
      const nowPerf = performance.now();
      if (network.enabled && nowPerf - network.lastSync > SYNC_INTERVAL) {
        network.lastSync = nowPerf;
        syncPlayers();
      }
      if (network.enabled && nowPerf - network.lastBoardFetch > CONFIG.boardIntervalMs) {
        network.lastBoardFetch = nowPerf;
        fetchBoard();
      }
      prunePeers();

      if (!state.running || state.paused) {
        state.danger = computeDanger();
        updateStars(dt);
        updateUI(); // rafraichit le classement/hud meme en pause ou avant le start
        updateShake(dt);
        const shake = getShakeOffset();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(shake.x, shake.y);
        drawBackground();
        drawAnomaly();
        drawGuides();
        drawRelays();
        drawHazards();
        drawPowerups();
        drawOrbs();
        drawPeerPulses();
        drawPeers();
        drawPlayer();
        drawParticles();
        ctx.restore();
        return;
      }

      const difficulty = 1 + Math.min(state.time * 0.03, 2.0);
      const slowFactor = state.effects.slow > 0 ? 0.6 : (state.assistSlow > 0 ? 0.82 : 1);
      const effectiveDt = dt * slowFactor;

      state.time += dt;
      state.score += dt * 6.5 * state.multiplier;
      if (state.multiplier > 1) {
        const idle = state.time - state.lastDelivery;
        if (idle > CONFIG.flow.decayDelay) {
          state.multiplier = Math.max(1, state.multiplier - dt * CONFIG.flow.decayRate);
        }
      }
      if (state.score > state.sessionBest || (state.score === state.sessionBest && state.time > state.sessionBestTime)) {
        state.sessionBest = state.score;
        state.sessionBestTime = state.time;
      }

      const waveMods = updateWave(dt);
      updateAnomaly(dt);

      state.timers.hazard -= effectiveDt;
      if (state.timers.hazard <= 0) {
        const density = state.hazards.length / CONFIG.maxHazards;
        const integrityRatio = state.maxIntegrity ? state.integrity / state.maxIntegrity : 1;
        const extra = (() => {
          if (density > 0.65 || integrityRatio < 0.45) return 0;
          let bonus = 0;
          if (state.time > 35 && Math.random() < clamp((state.time - 35) / 70, 0, 0.45)) bonus += 1;
          if (state.time > 80 && Math.random() < 0.2) bonus += 1;
          return bonus;
        })();
        const waves = 1 + extra;
        let spawned = 0;
        for (let i = 0; i < waves; i++) {
          if (spawnHazard(difficulty, waveMods)) spawned += 1;
          else break;
        }

        const decay = Math.exp(-state.time * CONFIG.spawn.hazardDecay);
        const base = CONFIG.spawn.hazardBase * decay + CONFIG.spawn.hazardMin;
        const rate = waveMods.spawnRate || 1;
        const ease = getSpawnEase();
        state.timers.hazard = (spawned ? base + Math.random() * CONFIG.spawn.hazardJitter : CONFIG.spawn.hazardFallback) * rate * ease;
      }

      state.timers.orb -= effectiveDt;
      if (state.timers.orb <= 0) {
        spawnOrb();
        state.timers.orb = CONFIG.spawn.orbBase + Math.random() * CONFIG.spawn.orbJitter;
      }

      state.timers.powerup -= effectiveDt;
      if (state.timers.powerup <= 0) {
        spawnPowerup();
        state.timers.powerup = CONFIG.spawn.powerupBase + Math.random() * CONFIG.spawn.powerupJitter;
      }

      if (state.pulseCooldown > 0) state.pulseCooldown -= dt;
      if (state.comboFlash > 0) state.comboFlash -= dt;

      updateEffects(dt);
      updateStars(dt);
      updatePlayer(dt);
      applyPeerPulseEffects(dt);
      updateRelays(dt);
      updateHazards(dt, difficulty);
      updatePowerups(dt);
      updateOrbs(dt);
      updateTrail(dt);
      checkPeerCollisions();
      updateParticles(dt);
      state.danger = computeDanger();
      updateUI();

      const shake = getShakeOffset();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(shake.x, shake.y);
      drawBackground();
      drawAnomaly();
      drawGuides();
      drawRelays();
      drawHazards();
      drawPowerups();
      drawOrbs();
      drawPeerPulses();
      drawPeers();
      drawTrail();
      drawPlayer();
      drawParticles();
      ctx.restore();
    }

    function loop(timestamp) {
      const dt = Math.min((timestamp - state.last) / 1000, 0.035);
      state.last = timestamp;
      gameStep(dt);
      requestAnimationFrame(loop);
    }

    function endGame() {
      state.running = false;
      updateUI();
      message.classList.remove('hidden');
      statusEl.textContent = 'Mission terminee';
      summaryEl.textContent = `Score ${Math.floor(state.score)} | Flux max x${state.maxMultiplier.toFixed(1)} | Temps ${formatTime(state.time)}`;
      statsEl.innerHTML = `
        <div class="stat-row"><span>Temps mission</span><br>${formatTime(state.time)}</div>
        <div class="stat-row"><span>Meilleur temps</span><br>${formatTime(state.sessionBestTime)}</div>
        <div class="stat-row"><span>Noyaux collectes</span><br>${state.stats.cores}</div>
        <div class="stat-row"><span>Livraisons</span><br>${state.stats.deliveries}</div>
        <div class="stat-row"><span>Relais charges</span><br>${state.stats.relays}</div>
        <div class="stat-row"><span>Collisions subies</span><br>${state.stats.hits}</div>
      `;
      submitScore();
    }

    function togglePause() {
      if (!state.running) return;
      state.paused = !state.paused;
      message.classList.toggle('hidden', !state.paused);
      if (state.paused) {
        statusEl.textContent = 'Pause';
        summaryEl.textContent = 'Respire un coup. Appuie sur P ou Entrer pour reprendre.';
      } else {
        statusEl.textContent = '';
        summaryEl.textContent = 'Collecte les noyaux, charge les relais, profite des anomalies et declenche l onde de choc quand la tempete se resserre.';
      }
    }

    function handleKey(code, pressed) {
      if (['ArrowUp', 'KeyW', 'KeyZ', 'KeyI'].includes(code)) input.up = pressed;
      if (['ArrowDown', 'KeyS', 'KeyK'].includes(code)) input.down = pressed;
      if (['ArrowLeft', 'KeyA', 'KeyQ', 'KeyJ'].includes(code)) input.left = pressed;
      if (['ArrowRight', 'KeyD', 'KeyL'].includes(code)) input.right = pressed;
    }

    function clearTouchInput() {
      touchInput.up = false;
      touchInput.down = false;
      touchInput.left = false;
      touchInput.right = false;
    }

    function updateTouchInput(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const px = (clientX - rect.left) * (canvas.width / rect.width);
      const py = (clientY - rect.top) * (canvas.height / rect.height);
      const dx = px - state.player.x;
      const dy = py - state.player.y;
      const dead = 18;
      touchInput.left = dx < -dead;
      touchInput.right = dx > dead;
      touchInput.up = dy < -dead;
      touchInput.down = dy > dead;
    }

    document.addEventListener('keydown', (e) => {
      handleKey(e.code, true);
      if (e.code === 'Space') {
        e.preventDefault();
        triggerPulse();
      }
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.code === 'KeyB') {
        triggerBoost();
      }
      if (e.code === 'KeyP' || e.code === 'Enter') {
        togglePause();
      }
      if (e.code === 'KeyT') {
        setTutorialOpen(!state.tutorialOpen);
      }
    });

    document.addEventListener('keyup', (e) => {
      handleKey(e.code, false);
    });

    startBtn.addEventListener('click', () => {
      const proposed = (nameInput.value || '').trim();
      network.name = proposed || `Operateur-${Math.random().toString(36).slice(2, 5)}`;
      state.name = network.name;
      resetGame();
      nameInput.value = network.name;
    });

    tutorialBtn.addEventListener('click', () => {
      setTutorialOpen(true);
    });

    tutorialClose.addEventListener('click', () => {
      setTutorialOpen(false);
    });

    liveToggle.addEventListener('click', () => {
      setLiveOverlay(!state.liveboardOpen);
    });

    liveClose.addEventListener('click', () => {
      setLiveOverlay(false);
    });

    if (contrastToggle) {
      contrastToggle.addEventListener('change', () => {
        prefs.highContrast = contrastToggle.checked;
        writePref(PREF_KEYS.highContrast, prefs.highContrast);
        applyPreferenceClasses();
      });
    }

    if (motionToggle) {
      motionToggle.addEventListener('change', () => {
        prefs.reducedMotion = motionToggle.checked;
        writePref(PREF_KEYS.reducedMotion, prefs.reducedMotion);
        applyPreferenceClasses();
      });
    }

    if (shakeToggle) {
      shakeToggle.addEventListener('change', () => {
        prefs.shake = shakeToggle.checked;
        writePref(PREF_KEYS.shake, prefs.shake);
        if (!prefs.shake) state.shake.power = 0;
        syncPreferenceControls();
      });
    }

    if (shakeRange) {
      shakeRange.addEventListener('input', () => {
        const value = Math.min(100, Math.max(0, Number(shakeRange.value) || 0));
        prefs.shakeIntensity = value / 100;
        writePref(PREF_KEYS.shakeIntensity, prefs.shakeIntensity);
        syncPreferenceControls();
      });
    }

    pulseBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); triggerPulse(); });
    if (boostBtn) {
      boostBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); triggerBoost(); });
    }

    document.querySelectorAll('.dpad button[data-dir]').forEach(btn => {
      btn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        const dir = btn.dataset.dir;
        if (dir === 'up') touchInput.up = true;
        if (dir === 'down') touchInput.down = true;
        if (dir === 'left') touchInput.left = true;
        if (dir === 'right') touchInput.right = true;
      });
      btn.addEventListener('pointerup', () => {
        const dir = btn.dataset.dir;
        if (dir === 'up') touchInput.up = false;
        if (dir === 'down') touchInput.down = false;
        if (dir === 'left') touchInput.left = false;
        if (dir === 'right') touchInput.right = false;
      });
      btn.addEventListener('pointerleave', () => {
        const dir = btn.dataset.dir;
        if (dir === 'up') touchInput.up = false;
        if (dir === 'down') touchInput.down = false;
        if (dir === 'left') touchInput.left = false;
        if (dir === 'right') touchInput.right = false;
      });
    });

    const endTouch = () => {
      if (!touchInput.active) return;
      touchInput.active = false;
      touchInput.pointerId = null;
      clearTouchInput();
    };

    canvas.addEventListener('pointerdown', (e) => {
      if (e.pointerType !== 'touch') return;
      touchInput.active = true;
      touchInput.pointerId = e.pointerId;
      canvas.setPointerCapture(e.pointerId);
      updateTouchInput(e.clientX, e.clientY);
    });

    canvas.addEventListener('pointermove', (e) => {
      if (!touchInput.active || e.pointerId !== touchInput.pointerId) return;
      updateTouchInput(e.clientX, e.clientY);
    });

    canvas.addEventListener('pointerup', endTouch);
    canvas.addEventListener('pointercancel', endTouch);

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('pagehide', leaveServer);
    window.addEventListener('beforeunload', leaveServer);
    window.addEventListener('pageshow', () => { leaveSent = false; });

    applyPreferences();
    loadBests();
    renderHighscores();
    renderLiveboard();
    nameInput.value = network.name;
    resizeCanvas();
    initRelays();
    setLiveOverlay(false);
    setTutorialOpen(false, false);
    state.last = performance.now();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
